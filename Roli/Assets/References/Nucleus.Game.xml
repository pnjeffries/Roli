<?xml version="1.0"?>
<doc>
    <assembly>
        <name>Nucleus.Game</name>
    </assembly>
    <members>
        <member name="T:Nucleus.Game.Actions.AbortAction">
            <summary>
            Action which is used to abort multi-step operations
            </summary>
        </member>
        <member name="T:Nucleus.Game.Actions.UseItemAction">
            <summary>
            Use an item
            </summary>
        </member>
        <member name="M:Nucleus.Game.Actions.UseItemAction.#ctor(System.String,Nucleus.Model.Element,Nucleus.Game.IEffect[])">
            <summary>
            Constructor for using an item.
            If the item is consumable, will automatically add a consume effect.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
            <param name="selfEffects"></param>
        </member>
        <member name="M:Nucleus.Game.Actions.UseItemAction.#ctor(System.String,Nucleus.Model.Element,System.Collections.Generic.IList{Nucleus.Game.IEffect},System.Collections.Generic.IList{Nucleus.Game.IEffect})">
            <summary>
            Constructor for using an item.
            If the item is consumable, will automatically add a consume effect.
            </summary>
            <param name="name"></param>
            <param name="item"></param>
            <param name="selfEffects"></param>
        </member>
        <member name="T:Nucleus.Game.Actions.OpenDoorAction">
            <summary>
            An action to open a door
            </summary>
        </member>
        <member name="T:Nucleus.Game.ActionCellInputTrigger">
            <summary>
            An ActionInputTrigger that is contextual to a particular map cell
            </summary>
        </member>
        <member name="F:Nucleus.Game.ActionCellInputTrigger._TargetCell">
            <summary>
            Private backing member variable for the TargetCell property
            </summary>
        </member>
        <member name="P:Nucleus.Game.ActionCellInputTrigger.TargetCell">
            <summary>
            The index of the cell that is targeted for this action
            </summary>
        </member>
        <member name="T:Nucleus.Game.DropItemAction">
            <summary>
            Drop an item
            </summary>
        </member>
        <member name="T:Nucleus.Game.RangedAOEAttackActionFactory">
            <summary>
            Action factory for ranged area-of-effect attack actions
            </summary>
        </member>
        <member name="P:Nucleus.Game.RangedAOEAttackActionFactory.Range">
            <summary>
            The maximum range of the attack
            </summary>
        </member>
        <member name="F:Nucleus.Game.RangedAOEAttackActionFactory._ProjectileCollider">
            <summary>
            The collider used to check for projectile collision
            </summary>
        </member>
        <member name="T:Nucleus.Game.PrepareToDropItemAction">
            <summary>
            An action which prepares to drop an item
            </summary>
        </member>
        <member name="T:Nucleus.Game.ChangeSelectedItemAction">
            <summary>
            An action which changes the selected item in the actor's inventory
            </summary>
        </member>
        <member name="M:Nucleus.Game.ChangeSelectedItemAction.#ctor(Nucleus.Game.IEffect,Nucleus.Game.ActionInputTrigger)">
            <summary>
            Effect + trigger constructor
            </summary>
            <param name="effect"></param>
            <param name="trigger"></param>
        </member>
        <member name="T:Nucleus.Game.ResourceAction">
            <summary>
            An abstract base action which requires a resource 
            </summary>
        </member>
        <member name="P:Nucleus.Game.ResourceAction.ResourceRequired">
            <summary>
            The resource required to execute this action
            </summary>
        </member>
        <member name="T:Nucleus.Game.ExitStageAction">
            <summary>
            Action which allows an actor to move between stages
            </summary>
        </member>
        <member name="T:Nucleus.Game.ActionFactory">
            <summary>
            Base class for objects which can be used to generate actions dynamically
            </summary>
        </member>
        <member name="P:Nucleus.Game.ActionFactory.ActionName">
            <summary>
            The name to be assigned to the generated actions
            </summary>
        </member>
        <member name="M:Nucleus.Game.ActionFactory.GenerateActions(Nucleus.Game.TurnContext,Nucleus.Game.AvailableActions)">
            <summary>
            Generate actions given the specified context and add them to the available actions
            </summary>
            <param name="context"></param>
            <param name="addTo"></param>
        </member>
        <member name="M:Nucleus.Game.ActionFactory.TargetableCells(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Game.TurnContext)">
            <summary>
            Generate a list of the cells (if any) which may be targetted by the actions this
            factory can produce from the specified position and in the specified direction.
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.ActionFactory.TargetableCells(Nucleus.Game.TurnContext)">
            <summary>
            Generate a list of the cells (if any) which may be targetted by the actions this
            factory can produce.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.ActionInputTrigger">
            <summary>
            Base class representing the input conditions under which an action will be triggered by the player
            </summary>
        </member>
        <member name="F:Nucleus.Game.ActionInputTrigger._Input">
            <summary>
            Private backing member variable for the Input property
            </summary>
        </member>
        <member name="P:Nucleus.Game.ActionInputTrigger.Input">
            <summary>
            The input function which will trigger this action.
            </summary>
        </member>
        <member name="M:Nucleus.Game.ActionInputTrigger.Matches(Nucleus.Game.ActionInputTrigger)">
            <summary>
            Does this input trigger match the given one?
            For the purposes of matching, top level input
            functions are taken to be equivalent to any of
            their sub-inputs
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.BumpAttackAction">
            <summary>
            A 'bump' melee attack action
            </summary>
        </member>
        <member name="T:Nucleus.Game.CellTargetingAction">
            <summary>
            A base class for actions which target a particular cell
            </summary>
        </member>
        <member name="T:Nucleus.Game.ElementTargetingAction">
            <summary>
            An action which targets an element
            </summary>
        </member>
        <member name="T:Nucleus.Game.AOEAttackActionFactory">
            <summary>
            An action factory to produce AOEAttackActions
            </summary>
        </member>
        <member name="F:Nucleus.Game.AOEAttackActionFactory._Offsets">
            <summary>
            Private backing member variable for the Offsets property
            </summary>
        </member>
        <member name="P:Nucleus.Game.AOEAttackActionFactory.Offsets">
            <summary>
            The array of cell offsets which is to be used to determine the area of effect 
            of the action.  These are the offset vectors of the cell locations to be 
            affected relative to the actor position, when the actor is orientated at
            0 degrees (i.e. facing along the X-axis).  These offsets will be automatically 
            rotatetd in order to give the pattern of effect in other directions.
            </summary>
        </member>
        <member name="F:Nucleus.Game.AOEAttackActionFactory._SourceSFX">
            <summary>
            Private backing member variable for the SourceSFX property
            </summary>
        </member>
        <member name="P:Nucleus.Game.AOEAttackActionFactory.SourceSFX">
            <summary>
            The keyword of the special effect to play at the source of the attack
            </summary>
        </member>
        <member name="P:Nucleus.Game.AOEAttackActionFactory.Effects">
            <summary>
            The blueprint effects which will be applied by actions
            </summary>
        </member>
        <member name="P:Nucleus.Game.AOEAttackActionFactory.SelfEffects">
            <summary>
            The blueprint effects which will be applied by actions
            </summary>
        </member>
        <member name="M:Nucleus.Game.AOEAttackActionFactory.#ctor(Nucleus.Geometry.Vector[])">
            <summary>
            Creates an AOEAttackAction factory to create an attack pattern
            with the specified list offsets.
            </summary>
        </member>
        <member name="M:Nucleus.Game.AOEAttackActionFactory.#ctor(System.String,Nucleus.Geometry.Vector[])">
            <summary>
            Creates an AOEAttackAction factory to create an attack pattern
            with the specified list offsets.
            </summary>
        </member>
        <member name="M:Nucleus.Game.AOEAttackActionFactory.#ctor(System.Double[])">
            <summary>
            Creates an AOEAttackAction factory to create an attack pattern
            with the specified list of alternating X and Y offset components.
            </summary>
            <param name="offsetComponents"></param>
        </member>
        <member name="M:Nucleus.Game.AOEAttackActionFactory.#ctor(System.String,System.Double[])">
            <summary>
            Creates an AOEAttackAction factory to create an attack pattern
            with the specified list of alternating X and Y offset components.
            </summary>
            <param name="offsetComponents"></param>
        </member>
        <member name="M:Nucleus.Game.AOEAttackActionFactory.#ctor(System.Collections.Generic.IList{Nucleus.Game.IEffect},System.String,System.String,System.Double[])">
            <summary>
            Creates an AOEAttackAction factory to create an attack pattern
            with the specified list of alternating X and Y offset components.
            </summary>
            <param name="offsetComponents"></param>
        </member>
        <member name="M:Nucleus.Game.AOEAttackActionFactory.#ctor(System.Collections.Generic.IList{Nucleus.Game.IEffect},System.Collections.Generic.IList{Nucleus.Game.IEffect},System.String,System.String,System.Double[])">
            <summary>
            Creates an AOEAttackAction factory to create an attack pattern
            with the specified list of alternating X and Y offset components.
            </summary>
            <param name="offsetComponents"></param>
        </member>
        <member name="T:Nucleus.Game.DirectionalActionFactory">
            <summary>
            Base class for ActionFactory types which produce actions for all 
            surrounding directions
            </summary>
        </member>
        <member name="M:Nucleus.Game.DirectionalActionFactory.GenerateActions(Nucleus.Game.TurnContext,Nucleus.Game.AvailableActions)">
            <summary>
            Generate actions given the specified context and add them to the available actions.
            Basic implementation that provides the boilerplate for setting up different directions
            </summary>
            <param name="context"></param>
            <param name="addTo"></param>
        </member>
        <member name="M:Nucleus.Game.DirectionalActionFactory.ActionForDirection(Nucleus.Geometry.Vector,Nucleus.Geometry.Vector,Nucleus.Geometry.MapCell,Nucleus.Game.TurnContext)">
            <summary>
            Generate the action for the specified direction and trigger cell
            </summary>
            <param name="direction"></param>
            <param name="triggerCell"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.GameActionCollection">
            <summary>
            A collection of game actions
            </summary>
        </member>
        <member name="M:Nucleus.Game.GameActionCollection.FirstMatch(Nucleus.Game.ActionInputTrigger)">
            <summary>
            Find the first action in this collection with a matching
            input trigger to the one provided
            </summary>
            <param name="trigger"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.IActionsOverride">
            <summary>
            Interface for objects which override the generation of available
            actions for an actor in order to provide its own.
            </summary>
        </member>
        <member name="M:Nucleus.Game.IActionsOverride.GenerateOverrideActions(Nucleus.Game.TurnContext,Nucleus.Game.AvailableActions)">
            <summary>
            
            </summary>
            <param name="context"></param>
            <param name="addTo"></param>
        </member>
        <member name="T:Nucleus.Game.MoveCellAction">
            <summary>
            An action which will (attempt to) move an element from one
            map cell to another
            </summary>
        </member>
        <member name="F:Nucleus.Game.MoveCellAction._CellIndex">
            <summary>
            Private backing member variable for the CellIndex property
            </summary>
        </member>
        <member name="P:Nucleus.Game.MoveCellAction.CellIndex">
            <summary>
            The index of the cell this action will move an element into
            </summary>
        </member>
        <member name="T:Nucleus.Game.MultiCellTargetingAction">
            <summary>
            Base class for actions which may target multiple map cells
            </summary>
        </member>
        <member name="T:Nucleus.Game.PickUpAction">
            <summary>
            Action to pick up items
            </summary>
        </member>
        <member name="M:Nucleus.Game.PickUpAction.#ctor(Nucleus.Model.Element)">
            <summary>
            Creates an action to pick up the target item
            </summary>
            <param name="target"></param>
        </member>
        <member name="T:Nucleus.Game.WindUpAction">
            <summary>
            Action whereby a game element spends a turn preparing to use an
            item or ability
            </summary>
        </member>
        <member name="T:Nucleus.Game.TargetedAction`1">
            <summary>
            An action which targets particular element or place
            </summary>
            <typeparam name="TTarget"></typeparam>
        </member>
        <member name="F:Nucleus.Game.TargetedAction`1._Target">
            <summary>
            Private backing member variable for the Target property
            </summary>
        </member>
        <member name="P:Nucleus.Game.TargetedAction`1.Target">
            <summary>
            The target of the action
            </summary>
        </member>
        <member name="T:Nucleus.Game.WaitAction">
            <summary>
            Action whereby an element waits or rests for a turn
            </summary>
        </member>
        <member name="T:Nucleus.Game.BlueprintCell">
            <summary>
            A cell in a stage map blueprint
            </summary>
        </member>
        <member name="F:Nucleus.Game.BlueprintCell._GenerationType">
            <summary>
            Private backing member variable for the GenerationType property
            </summary>
        </member>
        <member name="P:Nucleus.Game.BlueprintCell.GenerationType">
            <summary>
            The generation type of the cell
            </summary>
        </member>
        <member name="F:Nucleus.Game.BlueprintCell._Room">
            <summary>
            Private backing member variable for the Room property
            </summary>
        </member>
        <member name="P:Nucleus.Game.BlueprintCell.Room">
            <summary>
            The room that the cell occupies
            </summary>
        </member>
        <member name="T:Nucleus.Game.CellGenerationType">
            <summary>
            An enum to store the type of a cell during map generation
            </summary>
        </member>
        <member name="M:Nucleus.Game.CellGenerationTypeExtensions.IsWall(Nucleus.Game.CellGenerationType)">
            <summary>
            Is this a wall type?
            </summary>
            <param name="genType"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.ExitPlacement">
            <summary>
            Enumerated value to represent different strategies for placing an exit in a room
            </summary>
        </member>
        <member name="T:Nucleus.Game.Room">
            <summary>
            Class to hold information about a room in a game level
            </summary>
        </member>
        <member name="F:Nucleus.Game.Room._Template">
            <summary>
            Private backing member variable for the Template property
            </summary>
        </member>
        <member name="P:Nucleus.Game.Room.Template">
            <summary>
            The template used to generate this Room
            </summary>
        </member>
        <member name="F:Nucleus.Game.Room._Bounds">
            <summary>
            Private backing member variable for the Bounds property
            </summary>
        </member>
        <member name="P:Nucleus.Game.Room.Bounds">
            <summary>
            The rectangular bounding region within which this room lies on the map
            </summary>
        </member>
        <member name="F:Nucleus.Game.Room._Connections">
            <summary>
            Private backing member variable for the Connections property
            </summary>
        </member>
        <member name="P:Nucleus.Game.Room.Connections">
            <summary>
            The rooms which connect to this one
            </summary>
        </member>
        <member name="M:Nucleus.Game.Room.IsConnectedTo(Nucleus.Game.Room,System.Int32)">
            <summary>
            Is this room connected to the other within a specified number of degrees
            of separation
            </summary>
            <param name="other"></param>
            <param name="level">The degrees of separation</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.RoomCollection">
            <summary>
            A collection of rooms
            </summary>
        </member>
        <member name="T:Nucleus.Game.RoomTemplateCollection">
            <summary>
            A collection of room templates
            </summary>
        </member>
        <member name="M:Nucleus.Game.RoomTemplateCollection.GetAllOfType(Nucleus.Game.RoomType)">
            <summary>
            Get all templates in this collection of the specified type
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.RoomType">
            <summary>
            Room type enum
            </summary>
        </member>
        <member name="T:Nucleus.Game.StageStyle">
            <summary>
            A style which holds data about a stage to be generated
            </summary>
        </member>
        <member name="P:Nucleus.Game.StageStyle.Templates">
            <summary>
            The collection of templates to be used to generate rooms
            </summary>
        </member>
        <member name="P:Nucleus.Game.StageStyle.DoorChance">
            <summary>
            The chance to generate a door on designated doorway tiles
            </summary>
        </member>
        <member name="P:Nucleus.Game.StageStyle.MinLoopSize">
            <summary>
            The minimum size of loop before two rooms will connect into one another
            </summary>
        </member>
        <member name="M:Nucleus.Game.StageStyle.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Game.StageStyle.#ctor(Nucleus.Game.RoomTemplate[])">
            <summary>
            Templates constructor
            </summary>
            <param name="templates"></param>
        </member>
        <member name="M:Nucleus.Game.StageStyle.#ctor(System.String,Nucleus.Game.RoomTemplate[])">
            <summary>
            Templates constructor
            </summary>
            <param name="name"></param>
            <param name="templates"></param>
        </member>
        <member name="T:Nucleus.Game.Artitecture.WeightedTable`1">
            <summary>
            A table of objects and their weightings.  A roll can be made
            on this table to randomly decide on an item from the table
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Nucleus.Game.Artitecture.WeightedTable`1.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Game.Artitecture.WeightedTable`1.#ctor(`0[])">
            <summary>
            Create a table of items with equal weighting of 1 for each.
            </summary>
            <param name="items"></param>
        </member>
        <member name="M:Nucleus.Game.Artitecture.WeightedTable`1.SumWeights">
            <summary>
            Calculate the total of all weighting values in this table
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Artitecture.WeightedTable`1.Roll(System.Random)">
            <summary>
            Roll on this table and randomly return a result with a probability
            based on the weighting values
            </summary>
            <param name="rng"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.Cards.Card">
            <summary>
            Base class for card-type objects
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCard._Suit">
            <summary>
            Private backing member variable for the Suit property
            </summary>
        </member>
        <member name="P:Nucleus.Game.Cards.PlayingCard.Suit">
            <summary>
            The suit of this playing card
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCard._Rank">
            <summary>
            Private backing member variable for the Rank property
            </summary>
        </member>
        <member name="P:Nucleus.Game.Cards.PlayingCard.Rank">
            <summary>
            The rank of this playing card
            </summary>
        </member>
        <member name="M:Nucleus.Game.Cards.PlayingCard.BuildDeck">
            <summary>
            Build a standard deck of 52 playing cards
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.Cards.PlayingCardRank">
            <summary>
            Enumerated value representing the rank of a playing card
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardRank.Ace">
            <summary>
            Ace
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardRank.Two">
            <summary>
            Two
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardRank.Three">
            <summary>
            Three
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardRank.Four">
            <summary>
            Four
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardRank.Five">
            <summary>
            Five
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardRank.Six">
            <summary>
            Six
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardRank.Seven">
            <summary>
            Seven
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardRank.Eight">
            <summary>
            Eight
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardRank.Nine">
            <summary>
            Nine
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardRank.Ten">
            <summary>
            Ten
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardRank.Jack">
            <summary>
            Jack
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardRank.Queen">
            <summary>
            Queen
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardRank.King">
            <summary>
            King
            </summary>
        </member>
        <member name="T:Nucleus.Game.Cards.PlayingCardSuit">
            <summary>
            Enumerated value representing the suit of a playing card
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardSuit.Spades">
            <summary>
            Spades suit
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardSuit.Hearts">
            <summary>
            Hearts suit
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardSuit.Diamonds">
            <summary>
            Diamonds suit
            </summary>
        </member>
        <member name="F:Nucleus.Game.Cards.PlayingCardSuit.Clubs">
            <summary>
            Clubs suit
            </summary>
        </member>
        <member name="T:Nucleus.Game.Ability">
            <summary>
            Base class for element data components which propose an action
            </summary>
        </member>
        <member name="M:Nucleus.Game.Ability.PopulateActions(Nucleus.Game.TurnContext)">
            <summary>
            Populate the active element's AvailableActions component with actions
            generated by this ability
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:Nucleus.Game.Ability.IsDisabled(Nucleus.Game.TurnContext)">
            <summary>
            Is this ability currently disabled by a status effect?
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.BumpAttackAbility">
            <summary>
            Data component which confers the ability to bump-attack
            </summary>
        </member>
        <member name="P:Nucleus.Game.BumpAttackAbility.BaseDamage">
            <summary>
            The base damage of bump attacks
            </summary>
        </member>
        <member name="P:Nucleus.Game.BumpAttackAbility.BaseKnockback">
            <summary>
            The base knockback of bump attacks
            </summary>
        </member>
        <member name="P:Nucleus.Game.BumpAttackAbility.OtherEffects">
            <summary>
            Other effects to be applied to the target (besides standard damage and knockback)
            </summary>
        </member>
        <member name="T:Nucleus.Game.ChangeSelectedItemAbility">
            <summary>
            Ability which allows the actor to cycle through their selected item slot
            </summary>
        </member>
        <member name="F:Nucleus.Game.DirectionalItemUseAbility._ActionFactory">
            <summary>
            Private backing member variable for the ActionFactory property
            </summary>
        </member>
        <member name="P:Nucleus.Game.DirectionalItemUseAbility.ActionFactory">
            <summary>
            The ActionFactory used to generate actions
            </summary>
        </member>
        <member name="T:Nucleus.Game.DropAbility">
            <summary>
            Ability to drop items
            </summary>
        </member>
        <member name="T:Nucleus.Game.SlotItemDropAbility">
            <summary>
            Temporary ability to drop items
            </summary>
        </member>
        <member name="M:Nucleus.Game.IAbility.PopulateActions(Nucleus.Game.TurnContext)">
            <summary>
            Populate the active element's AvailableActions component with actions
            generated by this ability
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:Nucleus.Game.Components.Abilities.OpenDoorAbility">
            <summary>
            Data component which confers the ability to open doors
            </summary>
        </member>
        <member name="T:Nucleus.Game.Components.ConsumableItem">
            <summary>
            An item which has a limited number of uses, after which
            it is destroyed.
            </summary>
        </member>
        <member name="P:Nucleus.Game.Components.ConsumableItem.Uses">
            <summary>
            The remaining number of uses of the consumable
            </summary>
        </member>
        <member name="T:Nucleus.Game.Components.Door">
            <summary>
            A data component which marks an element as a door which may be opened or closed
            </summary>
        </member>
        <member name="M:Nucleus.Game.Components.Door.TryToOpen(Nucleus.Game.EffectContext)">
            <summary>
            Attempt to open this door
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.Components.IInventoryContainer">
            <summary>
            Interface for things which act as containers for other items/resources 
            in an inventory
            </summary>
        </member>
        <member name="T:Nucleus.Game.Components.IOutOfTurnMove">
            <summary>
            Interface for components which should be processed when
            the actor is moved outside of its normal turn order
            </summary>
        </member>
        <member name="M:Nucleus.Game.Components.IOutOfTurnMove.OutOfTurnMove(Nucleus.Game.TurnContext)">
            <summary>
            Called when the actor is moved outside of its ordinary
            turn order
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:Nucleus.Game.Components.ResourceCollection">
            <summary>
            A collection of resources
            </summary>
        </member>
        <member name="M:Nucleus.Game.Components.ResourceCollection.AddResourceQuantity(Nucleus.Game.Resource)">
            <summary>
            Add the specified resource to the collection.
            If an entry of the given type already exists in the collection,
            the quantities will be combined instead.  If the maximum resource
            is capped the remainder will be returned.
            </summary>
            <param name="resource"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Components.ResourceCollection.ResourceQuantity(Nucleus.Game.ResourceType)">
            <summary>
            Find the quantity of the specified resourceType held in this collection
            </summary>
            <param name="resourceType"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Components.ResourceCollection.HasResourceQuantity(Nucleus.Game.Resource)">
            <summary>
            Does this collection contain at least the specified amount of the
            specified resource?
            </summary>
            <param name="resource"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Components.ResourceCollection.ReduceResourceQuantity(Nucleus.Game.ResourceType,System.Int32)">
            <summary>
            Reduce the quantity of the specified resource in this collection by the specified
            amount.
            </summary>
            <param name="resourceType"></param>
            <param name="amount"></param>
            <returns>True if sufficient quantity of resource existed in the collection to meet the full amount</returns>
        </member>
        <member name="M:Nucleus.Game.Components.ResourceCollection.DropResource(Nucleus.Game.Resource,Nucleus.Model.Element,Nucleus.Game.EffectContext)">
            <summary>
            Drop a specified amount of resource from that held in this collection.
            If the full amount cannot be dropped as much as is held will be dropped instead.
            </summary>
            <param name="resource"></param>
            <param name="dropper"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Components.ResourceCollection.DropAll(Nucleus.Model.Element,Nucleus.Game.EffectContext)">
            <summary>
            Drop all resources held in this collection
            </summary>
            <param name="dropper"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.CritHitter">
            <summary>
            Component which allows the element to which it is attached to perform critical hits
            </summary>
        </member>
        <member name="P:Nucleus.Game.CritHitter.BaseChance">
            <summary>
            The base chance of this element performing a critical hit
            </summary>
        </member>
        <member name="M:Nucleus.Game.CritHitter.CombinedCritChance(Nucleus.Game.EffectContext)">
            <summary>
            Determine the overall critical success chance
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.CritHitter.RollToCrit(Nucleus.Game.EffectContext)">
            <summary>
            Roll randomly to determine whether a critical success has been achieved
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.DamageVulnerabilities">
            <summary>
            Data component to store the vulnerabilities and resistances of elements to different
            forms of damage.
            </summary>
        </member>
        <member name="F:Nucleus.Game.DamageVulnerabilities._BaseFactor">
            <summary>
            Private backing member variable for the BaseFactor property
            </summary>
        </member>
        <member name="P:Nucleus.Game.DamageVulnerabilities.BaseFactor">
            <summary>
            The default factor to be applied to damage types not explicitly listed
            </summary>
        </member>
        <member name="F:Nucleus.Game.DamageVulnerabilities._Vulnerabilities">
            <summary>
            Private backing member variable for the Vulnerabilities property
            </summary>
        </member>
        <member name="P:Nucleus.Game.DamageVulnerabilities.Vulnerabilities">
            <summary>
            The map of vulnerability factors for different damage types.  The amount of damage 
            taken will be multiplied by these factors for the relevant damage type.  Lower than 1
            = resistant, greater than 1 = vulnerable.
            </summary>
        </member>
        <member name="M:Nucleus.Game.DamageVulnerabilities.#ctor">
            <summary>
            Creates a new empty DamageVulnerabilities data component
            </summary>
        </member>
        <member name="M:Nucleus.Game.DamageVulnerabilities.#ctor(System.Double)">
            <summary>
            Creates a DamageVulnerabilities component with the specified
            default damage multiplier.
            </summary>
            <param name="baseFactor"></param>
        </member>
        <member name="M:Nucleus.Game.DamageVulnerabilities.VulnerabilityTo(Nucleus.Game.DamageType)">
            <summary>
            Get the damage multiplier for the specified damage type
            </summary>
            <param name="damage"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DamageVulnerabilities.Add(Nucleus.Game.DamageType,System.Double)">
            <summary>
            Add a new vulnerability/immunity
            </summary>
            <param name="damageType">The damage type</param>
            <param name="vulnerability">The damage multiplication factor</param>
        </member>
        <member name="M:Nucleus.Game.DamageVulnerabilities.Defend(Nucleus.Game.Damage,Nucleus.Logs.IActionLog,Nucleus.Game.EffectContext)">
            <summary>
            Adjust the specified damage value based on this defense
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.DisableActions">
            <summary>
            Status effect that disables certain actions
            </summary>
        </member>
        <member name="T:Nucleus.Game.ElementWeight">
            <summary>
            Component which describes the weight of a game object
            </summary>
        </member>
        <member name="P:Nucleus.Game.ElementWeight.Weight">
            <summary>
            The base weight of the element
            </summary>
        </member>
        <member name="M:Nucleus.Game.ElementWeight.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Game.ElementWeight.#ctor(System.Double)">
            <summary>
            Weight constructor
            </summary>
            <param name="weight"></param>
        </member>
        <member name="P:Nucleus.Game.ElementWeight.KnockbackModifier">
            <summary>
            Get the knockback modifier for the current weight 
            </summary>
        </member>
        <member name="T:Nucleus.Game.EquipmentSlot">
            <summary>
            An item slot to which items may be equipped to put them into use
            </summary>
        </member>
        <member name="M:Nucleus.Game.EquipmentSlot.CanHold(Nucleus.Model.Element)">
            <summary>
            Can this slot hold the specified item?
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.ICritChanceModifier">
            <summary>
            Interface for components, status effects, items etc. that
            modify critical hit chance
            </summary>
        </member>
        <member name="M:Nucleus.Game.ICritChanceModifier.ModifyCritChance(System.Double,Nucleus.Logs.IActionLog,Nucleus.Game.EffectContext)">
            <summary>
            Modify a critical success chance
            </summary>
            <param name="critChance"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.IKnockbackModifier">
            <summary>
            Interface for components, items, status effects etc. which modify
            the amount of knockback done by an actor
            </summary>
        </member>
        <member name="M:Nucleus.Game.IKnockbackModifier.ModifyKnockback(System.Int32,Nucleus.Logs.IActionLog,Nucleus.Game.EffectContext)">
            <summary>
            Modify the specified base knockback
            </summary>
            <param name="knockback"></param>
            <param name="log"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.ItemSlot">
            <summary>
            A slot which can hold an inventory item
            </summary>
        </member>
        <member name="F:Nucleus.Game.ItemSlot._HotKey">
            <summary>
            Private backing member variable for the HotKey property
            </summary>
        </member>
        <member name="P:Nucleus.Game.ItemSlot.HotKey">
            <summary>
            The button bound to this equipment slot
            </summary>
        </member>
        <member name="F:Nucleus.Game.ItemSlot._Item">
            <summary>
            Private backing member variable for the Item property
            </summary>
        </member>
        <member name="P:Nucleus.Game.ItemSlot.Item">
            <summary>
            The item of equipment contained within this slot
            </summary>
        </member>
        <member name="M:Nucleus.Game.ItemSlot.#ctor(System.String,Nucleus.Game.InputFunction,Nucleus.Model.Element)">
            <summary>
            Creates a new equipment slot with the specified name, hotkey and starting item
            </summary>
            <param name="hotKey"></param>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Game.ItemSlot.CanHold(Nucleus.Model.Element)">
            <summary>
            Can this slot hold the specified item?
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.ItemSlot.DropItem(Nucleus.Model.Element,Nucleus.Game.EffectContext)">
            <summary>
            Drop the item held in this slot.
            This will remove the item from the slot.  If the
            item is a PickUp it will be added back to the map.
            </summary>
            <param name="dropper">The element dropping the item</param>
            <param name="context">The current context</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.ItemSlot.ToString">
            <summary>
            Get a text description of this slot
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.ItemSlotExtensions">
            <summary>
            Extension methods for item slots and collections thereof
            </summary>
        </member>
        <member name="M:Nucleus.Game.ItemSlotExtensions.GetFirstEmpty``1(System.Collections.Generic.IList{``0})">
            <summary>
            Get the first equipment slot that is not currently occupied
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.ItemSlotExtensions.GetFirstAvailableFor``1(System.Collections.Generic.IList{``0},Nucleus.Model.Element,System.Boolean)">
            <summary>
            Get the first equipment slot that is not currently occupied
            </summary>
            <param name="slots"></param>
            <param name="item">he item</param>
            <param name="replaceCurrent">If false, the slot will not be considered available if an item is
            already held there.</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.ItemSlotExtensions.DropAll``1(System.Collections.Generic.IList{``0},Nucleus.Model.Element,Nucleus.Game.EffectContext)">
            <summary>
            Drop all items in this collection
            </summary>
            <param name="dropper"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.ItemSlotExtensions.DropItem``1(System.Collections.Generic.IList{``0},Nucleus.Model.Element,Nucleus.Model.Element,Nucleus.Game.EffectContext)">
            <summary>
            Drop a specific item
            </summary>
            <typeparam name="TSlot"></typeparam>
            <param name="slots"></param>
            <param name="item"></param>
            <param name="dropper"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.ItemSlotExtensions.RemoveItem``1(System.Collections.Generic.IList{``0},Nucleus.Model.Element)">
            <summary>
            Remove the specified item from any slot which contains it in this collection
            </summary>
            <typeparam name="TSlot"></typeparam>
            <param name="slots"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.ItemSlotExtensions.RemoveAllItems``1(System.Collections.Generic.IList{``0})">
            <summary>
            Clear items from all slots in this collection
            </summary>
        </member>
        <member name="M:Nucleus.Game.ItemSlotExtensions.ContainsItem``1(System.Collections.Generic.IList{``0},Nucleus.Model.Element)">
            <summary>
            Do any of the slots in this collection contain the specified item?
            </summary>
            <typeparam name="TSlot"></typeparam>
            <param name="slots"></param>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.EquipmentSlotCollection">
            <summary>
            A collection of equipment slots
            </summary>
        </member>
        <member name="T:Nucleus.Game.EquippableItem">
            <summary>
            An element data component which can be used to tag items as
            being equippable
            </summary>
        </member>
        <member name="T:Nucleus.Game.ExitStageAbility">
            <summary>
            Grants the ability to move between stages through stage exits
            </summary>
        </member>
        <member name="T:Nucleus.Game.HitPoints">
            <summary>
            A data component to hold the hit points value of destructable elements
            </summary>
        </member>
        <member name="F:Nucleus.Game.HitPoints._Value">
            <summary>
            Private backing field for Value property
            </summary>
        </member>
        <member name="P:Nucleus.Game.HitPoints.Value">
            <summary>
            The current value of the hitpoints of the element
            </summary>
        </member>
        <member name="F:Nucleus.Game.HitPoints._Maximum">
            <summary>
            Private backing field for Maximum property
            </summary>
        </member>
        <member name="P:Nucleus.Game.HitPoints.Maximum">
            <summary>
            The maximum value of the hitpoints of the element
            </summary>
        </member>
        <member name="M:Nucleus.Game.HitPoints.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Game.HitPoints.#ctor(System.Double)">
            <summary>
            Constructor setting the value and maximum of the hitpoints value
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Nucleus.Game.AvailableActions">
            <summary>
            A data component which attaches to actor elements.
            Provides a collection of all available actions which
            are available to that actor
            </summary>
        </member>
        <member name="P:Nucleus.Game.AvailableActions.Actions">
            <summary>
            The collection of actions available to this element
            </summary>
        </member>
        <member name="M:Nucleus.Game.AvailableActions.ActionForInput(Nucleus.Game.InputFunction)">
            <summary>
            Get the action assigned to the specified user input function
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.AvailableActions.ActionForInput(Nucleus.Game.InputFunction,System.Int32)">
            <summary>
            Get the action assigned to the specified user input function
            </summary>
            <param name="input"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.DungeonArtitect">
            <summary>
            Generator class for dungeons
            </summary>
        </member>
        <member name="F:Nucleus.Game.DungeonArtitect._RNG">
            <summary>
            Random number generator
            </summary>
        </member>
        <member name="P:Nucleus.Game.DungeonArtitect.RNG">
            <summary>
            Get or set the random number generator
            </summary>
        </member>
        <member name="F:Nucleus.Game.DungeonArtitect._Blueprint">
            <summary>
            The blueprint that the generator will work on
            </summary>
        </member>
        <member name="P:Nucleus.Game.DungeonArtitect.Blueprint">
            <summary>
            The blueprint that the generator will work on
            </summary>
        </member>
        <member name="P:Nucleus.Game.DungeonArtitect.ExitPlaced">
            <summary>
            Has the level exit yet been placed?
            </summary>
        </member>
        <member name="P:Nucleus.Game.DungeonArtitect.Rooms">
            <summary>
            The collection of rooms created during the generation
            </summary>
        </member>
        <member name="P:Nucleus.Game.DungeonArtitect.Templates">
            <summary>
            The collection of templates to be used to generate rooms
            </summary>
        </member>
        <member name="P:Nucleus.Game.DungeonArtitect.Snapshots">
            <summary>
            A collection of 'snapshot' images of the dungeon being generated.
            By default this is null and no snapshots will be recorded.  If populated
            with a suitable container snapshots will be taken as each room is added
            </summary>
        </member>
        <member name="P:Nucleus.Game.DungeonArtitect.RecordSnapshots">
            <summary>
            Should snapshots be recorded at each generation stage?
            </summary>
        </member>
        <member name="P:Nucleus.Game.DungeonArtitect.PathToExit">
            <summary>
            The number of rooms typically found between the entry and exit
            </summary>
        </member>
        <member name="P:Nucleus.Game.DungeonArtitect.MinLoopSize">
            <summary>
            The minimum number of rooms on a route between two others
            before which a new connection will be considered
            </summary>
        </member>
        <member name="P:Nucleus.Game.DungeonArtitect.PreventParallelCorridors">
            <summary>
            If set to true, parallel corridors will be detected and prevented
            </summary>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.#ctor(System.Int32,System.Int32)">
            <summary>
            Creates a new dungeon artitect to work within the specified bounds
            </summary>
            <param name="iSize"></param>
            <param name="jSize"></param>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.#ctor(System.Int32,System.Int32,Nucleus.Game.StageStyle)">
            <summary>
            Creates a new dungeon artitect to work within the specified bounds
            using the specified style
            </summary>
            <param name="iSize"></param>
            <param name="jSize"></param>
            <param name="style"></param>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.TakeSnapshot">
            <summary>
            Take a snapshot of the current state of the blueprint and add it to the snapshots collection
            </summary>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.Generate(Nucleus.Game.RoomTemplate)">
            <summary>
            Generate a dungeon map
            </summary>
            <param name="startRoom">The room to start with</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.Generate(Nucleus.Game.RoomTemplate,Nucleus.Geometry.CompassDirection)">
            <summary>
            Generate a dungeon map
            </summary>
            <param name="startRoom">The room to start with</param>
            <param name="startDirection">The initial direction</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.Generate(System.Int32,System.Int32,Nucleus.Game.RoomTemplate,Nucleus.Geometry.CompassDirection)">
            <summary>
            Generate a dungeon map
            </summary>
            <param name="iStart"></param>
            <param name="jStart"></param>
            <param name="startRoom">The room to start with</param>
            <param name="startDirection">The initial direction</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.IsCellAvailable(System.Int32,System.Int32,System.Int32)">
            <summary>
            Check whether the specified cell is available for assignment
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.AvailableForDoorway(System.Int32,System.Int32,Nucleus.Geometry.CompassDirection,System.Int32)">
            <summary>
            Can a door be placed here?
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <param name="direction"></param>
            <param name="width"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.AreAllType(Nucleus.Geometry.IntRectangle,Nucleus.Game.CellGenerationType)">
            <summary>
            Are all cells within the specified rectangular region of the specified
            type?
            </summary>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.AreAllType(System.Int32,System.Int32,System.Int32,System.Int32,Nucleus.Game.CellGenerationType)">
            <summary>
            Are all cells within the specified rectangular region of the specified
            type?
            </summary>
            <param name="iMin"></param>
            <param name="iMax"></param>
            <param name="jMin"></param>
            <param name="jMax"></param>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.CheckAvailability(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Are the following range of cells all available?
            </summary>
            <param name="iMin"></param>
            <param name="iMax"></param>
            <param name="jMin"></param>
            <param name="jMax"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.CheckAvailability(Nucleus.Geometry.IntRectangle)">
            <summary>
            Are the selected range of cells all available?
            </summary>
            <param name="rect"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.CheckRoom(Nucleus.Geometry.IntRectangle)">
            <summary>
            Return the first room encountered within the specified bounds
            </summary>
            <param name="bounds"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.CheckRoom(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Return the first room encountered within the specified bounds
            </summary>
            <param name="iMin"></param>
            <param name="iMax"></param>
            <param name="jMin"></param>
            <param name="jMax"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.CountRoomCells(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Count up the number of cells belonging to each room in the specified zone
            </summary>
            <param name="iMin"></param>
            <param name="iMax"></param>
            <param name="jMin"></param>
            <param name="jMax"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.IsParallelToCorridor(System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Check whether there is a corridor running parallel to this region
            </summary>
            <param name="iMin"></param>
            <param name="iMax"></param>
            <param name="jMin"></param>
            <param name="jMax"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.IsParallelToCorridor(Nucleus.Geometry.IntRectangle)">
            <summary>
            Check whether there is a corridor running parallel to this region
            </summary>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.GenerateDoorway(System.Int32,System.Int32,Nucleus.Geometry.CompassDirection,System.Int32)">
            <summary>
            Generate a (possibly multi-tile) doorway
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <param name="direction"></param>
            <param name="template"></param>
            <param name="template2"></param>
            <param name="floorLevel"></param>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.NextRoom(Nucleus.Game.RoomTemplate)">
            <summary>
            Get the template of the next room to be placed
            </summary>
            <param name="currentRoom"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.DeleteCell(System.Int32,System.Int32,Nucleus.Game.Room)">
            <summary>
            'Delete' a cell in the blueprint by returning it to 
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <param name="room"></param>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.DeleteRoom(Nucleus.Game.Room)">
            <summary>
            Delete an existing room
            </summary>
            <param name="room"></param>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.GenerateRoom(Nucleus.Geometry.IntRectangle,Nucleus.Game.RoomTemplate)">
            <summary>
            Generate a rectangular room
            </summary>
            <param name="iMin"></param>
            <param name="iMax"></param>
            <param name="jMin"></param>
            <param name="jMax"></param>
            <param name="template"></param>
            <param name="floorLevel"></param>
            <param name="slopeDirection"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.GenerateRoom(System.Int32,System.Int32,System.Int32,System.Int32,Nucleus.Game.RoomTemplate)">
            <summary>
            Generate a rectangular room
            </summary>
            <param name="iMin"></param>
            <param name="iMax"></param>
            <param name="jMin"></param>
            <param name="jMax"></param>
            <param name="template"></param>
            <param name="floorLevel"></param>
            <param name="slopeDirection"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.SetBlock(System.Int32,System.Int32,System.Int32,System.Int32,Nucleus.Game.CellGenerationType,Nucleus.Game.Room)">
            <summary>
            Set a rectangular block of cells to the specified values
            </summary>
            <param name="iMin"></param>
            <param name="iMax"></param>
            <param name="jMin"></param>
            <param name="jMax"></param>
            <param name="genType"></param>
            <param name="room"></param>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.SetCell(System.Int32,System.Int32,Nucleus.Game.CellGenerationType,Nucleus.Game.Room)">
            <summary>
            Set a cell of the blueprint to the specified type
            </summary>
            <param name="i"></param>
            <param name="j"></param>
            <param name="genType"></param>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.ExitDirection(Nucleus.Game.ExitPlacement,Nucleus.Geometry.CompassDirection)">
            <summary>
            Determine an exit direction based on the current placement logic
            </summary>
            <param name="logic"></param>
            <param name="startDir"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.DungeonArtitect.RecursiveGrowth(System.Int32,System.Int32,Nucleus.Game.RoomTemplate,Nucleus.Geometry.CompassDirection,System.Boolean,Nucleus.Game.Room)">
            <summary>
            Generate a dungeon map via recursive growth
            </summary>
            <param name="iDoor"></param>
            <param name="jDoor"></param>
            <param name="template"></param>
            <param name="direction"></param>
            <param name="createDoor"></param>
            <param name="floorLevel"></param>
            <param name="parent"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.IEndOfTurn">
            <summary>
            Interface for data components which process at the end of 
            a turn.
            </summary>
        </member>
        <member name="M:Nucleus.Game.IEndOfTurn.EndOfTurn(Nucleus.Game.TurnContext)">
            <summary>
            Process the end of a turn
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:Nucleus.Game.Inertia">
            <summary>
            Data component which denotes resistance to knockback
            </summary>
        </member>
        <member name="F:Nucleus.Game.Inertia._Fixed">
            <summary>
            Private backing member variable for the Fixed property
            </summary>
        </member>
        <member name="P:Nucleus.Game.Inertia.Fixed">
            <summary>
            Gets or sets whether this component is fixed and immovable
            </summary>
        </member>
        <member name="T:Nucleus.Game.Inventory">
            <summary>
            The inventory of an element
            </summary>
        </member>
        <member name="F:Nucleus.Game.Inventory._Slots">
            <summary>
            Private backing member variable for the Slots property
            </summary>
        </member>
        <member name="P:Nucleus.Game.Inventory.Slots">
            <summary>
            The items contained within this inventory
            </summary>
        </member>
        <member name="F:Nucleus.Game.Inventory._Equipped">
            <summary>
            Private backing member variable for the Slots property
            </summary>
        </member>
        <member name="P:Nucleus.Game.Inventory.Equipped">
            <summary>
            The available equipment slots
            </summary>
        </member>
        <member name="P:Nucleus.Game.Inventory.EquippedItems">
            <summary>
            Get a list of all the unique items currently eqipped in
            an equipment slot.
            Generated as-needed.
            </summary>
        </member>
        <member name="P:Nucleus.Game.Inventory.Selected">
            <summary>
            The currently selected item slot
            </summary>
        </member>
        <member name="P:Nucleus.Game.Inventory.Resources">
            <summary>
            The resources within this inventory.  These are stackable items such 
            as money and ammunition which do not take up an inventory slot.
            </summary>
        </member>
        <member name="M:Nucleus.Game.Inventory.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Game.Inventory.#ctor(Nucleus.Game.Components.IInventoryContainer[])">
            <summary>
            Slots constructor.
            Any EquipmentSlots will form part of the Equipped collection,
            otherwise it will be used as a standard inventory slot
            </summary>
            <param name="slots"></param>
        </member>
        <member name="M:Nucleus.Game.Inventory.AddItem(Nucleus.Model.Element)">
            <summary>
            Add an item to the inventory in the next available slot.
            Returns true if the attempt was successful.
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Inventory.DropAll(Nucleus.Model.Element,Nucleus.Game.EffectContext)">
            <summary>
            Drop all items and resourrces in this inventory
            </summary>
            <param name="dropper"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Inventory.DropItem(Nucleus.Model.Element,Nucleus.Model.Element,Nucleus.Game.EffectContext)">
            <summary>
            Drop a specified item held in this inventory
            </summary>
            <param name="item"></param>
            <param name="dropper"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Inventory.DropResource(Nucleus.Game.Resource,Nucleus.Model.Element,Nucleus.Game.EffectContext)">
            <summary>
            Drop a quantity of a specified resource
            </summary>
            <param name="resource"></param>
            <param name="dropper"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Inventory.RemoveResource(Nucleus.Game.Resource)">
            <summary>
            Remove the specified amount of a resource from this inventory (if possible)
            </summary>
            <param name="resource"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Inventory.RemoveItem(Nucleus.Model.Element)">
            <summary>
            Remove an item from this inventory
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Inventory.ContainsItem(Nucleus.Model.Element)">
            <summary>
            Does this inventory contain the specified item?
            </summary>
            <param name="item"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Inventory.Equip(Nucleus.Model.Element)">
            <summary>
            Attempt to equip the specified item of equipment.
            Returns true if the attempt was successful.
            </summary>
            <param name="equipment"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Inventory.IsEquipped(Nucleus.Model.Element)">
            <summary>
            Is the specified item currently equipped?
            </summary>
            <param name="equipment"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Inventory.SelectNext">
            <summary>
            Select the next item slot after the currently selected one
            </summary>
        </member>
        <member name="M:Nucleus.Game.Inventory.SelectPrevious">
            <summary>
            Select the previous item slot before the currently selected one
            </summary>
        </member>
        <member name="T:Nucleus.Game.IStartOfTurn">
            <summary>
            Interface for data components which process at the start of 
            a turn.
            </summary>
        </member>
        <member name="M:Nucleus.Game.IStartOfTurn.StartOfTurn(Nucleus.Game.TurnContext)">
            <summary>
            Process the start of a turn
            </summary>
            <param name="context"></param>
        </member>
        <member name="T:Nucleus.Game.ItemActions">
            <summary>
            A data component for use on items which may be used via an action
            </summary>
        </member>
        <member name="F:Nucleus.Game.ItemActions._Prototype">
            <summary>
            Private backing member variable for the Prototype property
            </summary>
        </member>
        <member name="P:Nucleus.Game.ItemActions.Prototype">
            <summary>
            The prototype of the item action.
            </summary>
        </member>
        <member name="M:Nucleus.Game.ItemActions.#ctor">
            <summary>
            Creates a blank itemaction
            </summary>
        </member>
        <member name="M:Nucleus.Game.ItemActions.#ctor(Nucleus.Game.ActionFactory)">
            <summary>
            Creates an ItemAction using the default 
            WindUpAction as a prototype followed by actions
            generated using the specified action factory
            </summary>
        </member>
        <member name="T:Nucleus.Game.ItemSlotCollection">
            <summary>
            A collection of inventory item slots
            </summary>
        </member>
        <member name="T:Nucleus.Game.MapAwareness">
            <summary>
            Data component to store element field of view within a Cell Map
            </summary>
        </member>
        <member name="F:Nucleus.Game.MapAwareness.Visible">
            <summary>
            The value used to indicate that a cell is directly visible
            </summary>
        </member>
        <member name="F:Nucleus.Game.MapAwareness.Remembered">
            <summary>
            The value used to indicate that a cell is remembered
            </summary>
        </member>
        <member name="P:Nucleus.Game.MapAwareness.FieldOfView">
            <summary>
            The element field of view map
            </summary>
        </member>
        <member name="P:Nucleus.Game.MapAwareness.VisualRange">
            <summary>
            The visual range of the element
            </summary>
        </member>
        <member name="M:Nucleus.Game.MapAwareness.AwarenessOfCell(System.Int32)">
            <summary>
            Get the awareness of the specified cell
            </summary>
            <param name="cellIndex"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.MapAwareness.AwareOf(Nucleus.Model.Element,System.Boolean)">
            <summary>
            Is the owner of this component aware of the specified element?
            </summary>
            <param name="element"></param>
            <param name="includeAdjacent">If true, the element will be considered visible if any adjacent
            cell is visible</param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.MapAwareness.StageChanged(Nucleus.Game.GameStage)">
            <summary>
            Called when the stage is changed
            </summary>
            <param name="stage"></param>
        </member>
        <member name="T:Nucleus.Game.Memorable">
            <summary>
            A data component which can be used to tag elements that should remain
            in memory when not in direct line of sight
            </summary>
        </member>
        <member name="T:Nucleus.Game.MoveCellAbility">
            <summary>
            An element data component which indicates that the element is
            able to move between cells of its own volition and will generate
            suitable actions for open spaces
            </summary>
        </member>
        <member name="T:Nucleus.Game.ActionSelectionAI">
            <summary>
            AI component used to select actions to be performed by NPCs
            </summary>
        </member>
        <member name="M:Nucleus.Game.ActionSelectionAI.SelectAction(Nucleus.Game.TurnContext,Nucleus.Game.GameActionCollection)">
            <summary>
            Select an action from the specified collection
            </summary>
            <param name="context"></param>
            <param name="actions"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.PickUp">
            <summary>
            Element data component used to tag items which may be picked up
            and carried.
            </summary>
        </member>
        <member name="T:Nucleus.Game.PickUpAbility">
            <summary>
            Ability which allows an element to pick up
            </summary>
        </member>
        <member name="T:Nucleus.Game.TemporaryAbility">
            <summary>
            Base class for temporary abilities that are removed 
            </summary>
        </member>
        <member name="T:Nucleus.Game.QuickAttack">
            <summary>
            Component for weapon equipment which can be used for quick (bump)
            attacks.
            </summary>
        </member>
        <member name="P:Nucleus.Game.QuickAttack.Effects">
            <summary>
            The effects which are to be applied when this item is equipped
            and used in a quick attack
            </summary>
        </member>
        <member name="M:Nucleus.Game.QuickAttack.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Game.QuickAttack.#ctor(Nucleus.Game.IEffect[])">
            <summary>
            Effects constructor
            </summary>
            <param name="effects"></param>
        </member>
        <member name="M:Nucleus.Game.QuickAttack.#ctor(System.Double,Nucleus.Game.DamageType,System.Double)">
            <summary>
            Damage + Knockback constructor.
            Automatically creates a damage and knockback effect with the specified
            values
            </summary>
            <param name="damage"></param>
            <param name="damageType"></param>
            <param name="knockback"></param>
        </member>
        <member name="T:Nucleus.Game.Effects.ApplyActorStatusEffect">
            <summary>
            Effect which applies a status effect to the actor when a target
            is valid.  Used in preference to a standard SelfEffect when the
            status to be applied works per target hit (for example, with combos)
            </summary>
        </member>
        <member name="T:Nucleus.Game.Effects.AddAbilityEffect">
            <summary>
            An effect which adds an ability to an 
            </summary>
        </member>
        <member name="F:Nucleus.Game.Effects.AddAbilityEffect._Ability">
            <summary>
            Private backing member variable for the Ability property
            </summary>
        </member>
        <member name="P:Nucleus.Game.Effects.AddAbilityEffect.Ability">
            <summary>
            The ability to be added to the target
            </summary>
        </member>
        <member name="T:Nucleus.Game.Effects.ApplyStatusEffect">
            <summary>
            Effect which applies a status effect to the target
            </summary>
        </member>
        <member name="P:Nucleus.Game.Effects.ApplyStatusEffect.StatusEffect">
            <summary>
            The template status effect to be applied
            </summary>
        </member>
        <member name="T:Nucleus.Game.Effects.ConsumeEffect">
            <summary>
            Consume a use of a consumable item, and remove it if spent
            </summary>
        </member>
        <member name="P:Nucleus.Game.Effects.ConsumeEffect.TargetOverride">
            <summary>
            The item to be consumed.
            If null, the contextual target will be used instead.
            </summary>
        </member>
        <member name="M:Nucleus.Game.Effects.ConsumeEffect.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Game.Effects.ConsumeEffect.#ctor(Nucleus.Model.Element)">
            <summary>
            Target item constructor
            </summary>
            <param name="targetItem">The item to be consumed</param>
        </member>
        <member name="M:Nucleus.Game.Effects.ConsumeEffect.#ctor(Nucleus.Game.Effects.ConsumeEffect)">
            <summary>
            Duplication constructor
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:Nucleus.Game.Effects.ConsumeResourceEffect">
            <summary>
            Effect which consumes a resource
            </summary>
        </member>
        <member name="T:Nucleus.Game.Effects.DropItemEffect">
            <summary>
            Effect which drops an item
            </summary>
        </member>
        <member name="T:Nucleus.Game.Effects.EquipItemEffect">
            <summary>
            Effect which will Equip an item
            </summary>
        </member>
        <member name="F:Nucleus.Game.Effects.EquipItemEffect._Item">
            <summary>
            The item to be equipped
            </summary>
        </member>
        <member name="P:Nucleus.Game.Effects.EquipItemEffect.Item">
            <summary>
            The item to be equipped
            </summary>
        </member>
        <member name="M:Nucleus.Game.Effects.EquipItemEffect.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Game.Effects.EquipItemEffect.#ctor(Nucleus.Model.Element)">
            <summary>
            Item constructor
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Game.Effects.EquipItemEffect.#ctor(Nucleus.Game.Effects.EquipItemEffect)">
            <summary>
            Duplication constructor
            </summary>
            <param name="effect"></param>
        </member>
        <member name="T:Nucleus.Game.Effects.ExitStageEffect">
            <summary>
            Effect which will move the actor through the
            specified stage exit
            </summary>
        </member>
        <member name="F:Nucleus.Game.Effects.ExitStageEffect._Exit">
            <summary>
            Private backing member variable for the Exit property
            </summary>
        </member>
        <member name="P:Nucleus.Game.Effects.ExitStageEffect.Exit">
            <summary>
            The exit to move the target through
            </summary>
        </member>
        <member name="M:Nucleus.Game.Effects.ExitStageEffect.#ctor(Nucleus.Game.StageExit)">
            <summary>
            Creates an ExitStageEffect to move through the specified
            exit
            </summary>
            <param name="exit"></param>
        </member>
        <member name="T:Nucleus.Game.Effects.HealEffect">
            <summary>
            An effect which heals an actor
            </summary>
        </member>
        <member name="P:Nucleus.Game.Effects.HealEffect.Healing">
            <summary>
            The hitpoints which will be recovered
            </summary>
        </member>
        <member name="T:Nucleus.Game.Effects.OpenDoorEffect">
            <summary>
            An effect which attempts to open a door
            </summary>
        </member>
        <member name="T:Nucleus.Game.Effects.ShowItemInfoEffect">
            <summary>
            Effect which displays item information to the user via a modal window
            </summary>
        </member>
        <member name="P:Nucleus.Game.Effects.ShowItemInfoEffect.Item">
            <summary>
            The item to show info for.  If left null the selected item from the
            actor's inventory will be displayed instead.
            </summary>
        </member>
        <member name="M:Nucleus.Game.Effects.ShowItemInfoEffect.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Game.Effects.ShowItemInfoEffect.#ctor(Nucleus.Model.Element)">
            <summary>
            Item constructor
            </summary>
            <param name="item"></param>
        </member>
        <member name="M:Nucleus.Game.Effects.ShowItemInfoEffect.#ctor(Nucleus.Game.Effects.ShowItemInfoEffect)">
            <summary>
            Duplication constructor
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:Nucleus.Game.Combo">
            <summary>
            Status effect which describes the state of having scored multiple hits
            in quick succession
            </summary>
        </member>
        <member name="P:Nucleus.Game.Combo.Hits">
            <summary>
            The number of hits in this combo
            </summary>
        </member>
        <member name="P:Nucleus.Game.Combo.Description">
            <summary>
            Description of the combo
            </summary>
        </member>
        <member name="T:Nucleus.Game.Strong">
            <summary>
            Status effect which increases knockback power
            </summary>
        </member>
        <member name="T:Nucleus.Game.Resource">
            <summary>
            A specific quantity of a specific type of collectable resource
            </summary>
        </member>
        <member name="P:Nucleus.Game.Resource.ResourceType">
            <summary>
            Get the type of resource this represents
            </summary>
        </member>
        <member name="P:Nucleus.Game.Resource.Quantity">
            <summary>
            The quantity of the resource
            </summary>
        </member>
        <member name="M:Nucleus.Game.Resource.CreatePickup">
            <summary>
            Create a game element to represent a pickup for this resource
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.ResourcePickUp">
            <summary>
            Pickup item which represents a quantity of a certain resource
            </summary>
        </member>
        <member name="P:Nucleus.Game.ResourcePickUp.Resource">
            <summary>
            The resource represented by this pickup
            </summary>
        </member>
        <member name="T:Nucleus.Game.ResourceType">
            <summary>
            Represents a type of resource.
            </summary>
        </member>
        <member name="P:Nucleus.Game.ResourceType.Symbol">
            <summary>
            The shorthand symbol used to represent the resource type
            </summary>
        </member>
        <member name="M:Nucleus.Game.ResourceType.#ctor(System.String)">
            <summary>
            Constructor
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Game.ResourceType.#ctor(System.String,System.String)">
            <summary>
            Name + symbol constructor
            </summary>
            <param name="name"></param>
            <param name="symbol"></param>
        </member>
        <member name="T:Nucleus.Game.StageExit">
            <summary>
            A component which tags an object as a gate between different stages
            </summary>
        </member>
        <member name="F:Nucleus.Game.StageExit._TravelTo">
            <summary>
            Private backing member variable for the TravelTo property
            </summary>
        </member>
        <member name="P:Nucleus.Game.StageExit.TravelTo">
            <summary>
            The stage which this exit allows travel to
            </summary>
        </member>
        <member name="F:Nucleus.Game.StageExit._CellIndex">
            <summary>
            Private backing member variable for the CellIndex property
            </summary>
        </member>
        <member name="P:Nucleus.Game.StageExit.CellIndex">
            <summary>
            The index of the cell to move to in the next stage
            </summary>
        </member>
        <member name="T:Nucleus.Game.Status">
            <summary>
            Element status effects
            </summary>
        </member>
        <member name="P:Nucleus.Game.Status.Effects">
            <summary>
            Get the current collection of status effects acting on the parent object
            </summary>
        </member>
        <member name="M:Nucleus.Game.Status.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Game.Status.#ctor(Nucleus.Game.IStatusEffect[])">
            <summary>
            Initial status effects constructor
            </summary>
            <param name="effects"></param>
        </member>
        <member name="M:Nucleus.Game.Status.AddEffect(Nucleus.Game.IStatusEffect)">
            <summary>
            Apply a new status effect to the parent element
            </summary>
            <param name="statusEffect"></param>
        </member>
        <member name="M:Nucleus.Game.Status.ClearEffects``1">
            <summary>
            Clear all effects of the specified type from the status
            </summary>
            <typeparam name="TEffect"></typeparam>
            <returns>True if any effects were successfully removed</returns>
        </member>
        <member name="M:Nucleus.Game.Status.GetEffect(System.Type)">
            <summary>
            Get the first status effect of the specified type currently
            applied to this component
            </summary>
            <param name="type"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Status.Defend(Nucleus.Game.Damage,Nucleus.Logs.IActionLog,Nucleus.Game.EffectContext)">
            <summary>
            Adjust the specified damage value based on this defense
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Status.ModifyCritChance(System.Double,Nucleus.Logs.IActionLog,Nucleus.Game.EffectContext)">
            <summary>
            Adjust a critical 
            </summary>
            <param name="critChance"></param>
            <param name="log"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.TemporaryStatus">
            <summary>
            A base class for status ailments or buffs which are temporary in
            nature and will expire after a number of turns.
            </summary>
        </member>
        <member name="F:Nucleus.Game.TemporaryStatus._LifeSpan">
            <summary>
            Private backing member variable for the LifeSpan property
            </summary>
        </member>
        <member name="P:Nucleus.Game.TemporaryStatus.LifeSpan">
            <summary>
            The number of turns remaining until this status effect should end.
            </summary>
        </member>
        <member name="T:Nucleus.Game.TurnCounter">
            <summary>
            Element data component which indicates that an element is able to take
            a turn, either directed by the player or by AI, and keeps track of the
            order in which these turns are taken.
            </summary>
        </member>
        <member name="F:Nucleus.Game.TurnCounter._CountDown">
            <summary>
            Private backing member variable for the CountDown property
            </summary>
        </member>
        <member name="P:Nucleus.Game.TurnCounter.CountDown">
            <summary>
            The count down until the element can take its next turn
            </summary>
        </member>
        <member name="F:Nucleus.Game.TurnCounter._Speed">
            <summary>
            Private backer for speed
            </summary>
        </member>
        <member name="P:Nucleus.Game.TurnCounter.Speed">
            <summary>
            The relative speed of action of the element
            </summary>
        </member>
        <member name="T:Nucleus.Game.UseItemAbility">
            <summary>
            Ability which enables the use of items
            </summary>
        </member>
        <member name="T:Nucleus.Game.VisionBlocker">
            <summary>
            An element data component that can be used to indicate that a cell blocks vision
            </summary>
        </member>
        <member name="P:Nucleus.Game.VisionBlocker.Opaque">
            <summary>
            Is this vision blocker currently blocking vision?
            </summary>
        </member>
        <member name="M:Nucleus.Game.VisionBlocker.IsTransparent(Nucleus.Model.Element)">
            <summary>
            Does this block LOS to the specified element
            </summary>
            <param name="toElement"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.WaitAbility">
            <summary>
            Ability data component which allows an element to take a 'wait' action
            </summary>
        </member>
        <member name="T:Nucleus.Game.Debug.DebugCommandLibrary">
            <summary>
            A class of debug commands which can be invoked to aid with testing and debugging
            </summary>
        </member>
        <member name="M:Nucleus.Game.Debug.DebugCommandLibrary.reset">
            <summary>
            Reset the game engine
            </summary>
        </member>
        <member name="T:Nucleus.Game.Debug.DebugCommandLibraryExtensions">
            <summary>
            Extension methods for DebugCommandLibrary
            </summary>
        </member>
        <member name="M:Nucleus.Game.Debug.DebugCommandLibraryExtensions.RunCommand``1(``0,System.String)">
            <summary>
            Attempt to execute the command string
            </summary>
            <typeparam name="T"></typeparam>
            <param name="debug"></param>
            <param name="command"></param>
        </member>
        <member name="T:Nucleus.Game.ActorOrientationEffect">
            <summary>
            Effect which changes the actor's orientation
            </summary>
        </member>
        <member name="F:Nucleus.Game.ActorOrientationEffect._OrientTo">
            <summary>
            Private backing member variable for the OrientTo property
            </summary>
        </member>
        <member name="P:Nucleus.Game.ActorOrientationEffect.OrientTo">
            <summary>
            The orientation angle (anticlockwise from +X) to set
            </summary>
        </member>
        <member name="M:Nucleus.Game.ActorOrientationEffect.#ctor(Nucleus.Model.Element,Nucleus.Geometry.MapCell)">
            <summary>
            Creates an orientation effect such that the specified element would
            face towards the specified cell
            </summary>
            <param name="actor"></param>
            <param name="cell"></param>
        </member>
        <member name="M:Nucleus.Game.ActorOrientationEffect.#ctor(Nucleus.Geometry.Vector)">
            <summary>
            Creates an orientation effect to face in the specified direction
            </summary>
            <param name="direction"></param>
        </member>
        <member name="M:Nucleus.Game.ActorOrientationEffect.#ctor(Nucleus.Game.ActorOrientationEffect)">
            <summary>
            Duplication constructor
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:Nucleus.Game.BasicEffect">
            <summary>
            Base class for simple effects
            </summary>
        </member>
        <member name="T:Nucleus.Game.DamageEffect">
            <summary>
            An effect which reduces element hitpoints
            </summary>
        </member>
        <member name="F:Nucleus.Game.DamageEffect._Damage">
            <summary>
            Private backing member variable for the Damage property
            </summary>
        </member>
        <member name="P:Nucleus.Game.DamageEffect.Damage">
            <summary>
            The value of the damage to be inflicted
            </summary>
        </member>
        <member name="T:Nucleus.Game.ResourceElement">
            <summary>
            A special subtype of GameElement which represents a resource.
            </summary>
        </member>
        <member name="T:Nucleus.Game.DamageType">
            <summary>
            Represents a type of damage
            </summary>
        </member>
        <member name="F:Nucleus.Game.DamageType.Base">
            <summary>
            The base damage type
            </summary>
        </member>
        <member name="F:Nucleus.Game.DamageType.Poison">
            <summary>
            The poison damage type
            </summary>
        </member>
        <member name="M:Nucleus.Game.DamageType.MultiplierFor(Nucleus.Model.Element)">
            <summary>
            Get the damage multiplier for the specified element
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.DisableEffect">
            <summary>
            Disable all actions for a turn
            </summary>
        </member>
        <member name="T:Nucleus.Game.EffectContext">
            <summary>
            The context within which an effect is being applied
            </summary>
        </member>
        <member name="P:Nucleus.Game.EffectContext.Actor">
            <summary>
            The element (if any) which is the root cause of this effect 
            </summary>
        </member>
        <member name="P:Nucleus.Game.EffectContext.Target">
            <summary>
            The element that is the primary target of the effect
            </summary>
        </member>
        <member name="P:Nucleus.Game.EffectContext.Stage">
            <summary>
            The current stage
            </summary>
        </member>
        <member name="P:Nucleus.Game.EffectContext.State">
            <summary>
            The current state
            </summary>
        </member>
        <member name="P:Nucleus.Game.EffectContext.SFX">
            <summary>
            The object used to trigger special effects in the front-end
            </summary>
        </member>
        <member name="P:Nucleus.Game.EffectContext.Direction">
            <summary>
            Direction for use in directional effects
            </summary>
        </member>
        <member name="P:Nucleus.Game.EffectContext.Map">
            <summary>
            Get the map (retrieved from current stage)
            </summary>
        </member>
        <member name="P:Nucleus.Game.EffectContext.RNG">
            <summary>
            The random number generator to be used to resolve stochastic effects
            </summary>
        </member>
        <member name="P:Nucleus.Game.EffectContext.Critical">
            <summary>
            Is this effect part of a critical success?
            </summary>
        </member>
        <member name="M:Nucleus.Game.EffectContext.CloneWithTarget(Nucleus.Model.Element)">
            <summary>
            Create a clone of this EffectContext but with the target element replaced with another
            </summary>
            <param name="target"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.EffectContext.IsPlayerAwareOf(Nucleus.Model.Element)">
            <summary>
            Is the player aware of the status of the specified element?
            </summary>
        </member>
        <member name="M:Nucleus.Game.EffectContext.IsPlayerControlled(Nucleus.Model.Element)">
            <summary>
            Is the specified element player-controlled?
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.IDirectionalEffect">
            <summary>
            Interface for effects which act in a particular direction
            </summary>
        </member>
        <member name="P:Nucleus.Game.IDirectionalEffect.Direction">
            <summary>
            The direction the effect acts in
            </summary>
        </member>
        <member name="T:Nucleus.Game.KnockbackEffect">
            <summary>
            An effect which moves the target in a particular direction (typically
            involuntarily).  Resistance to knockback is determined by the Inertia component.
            </summary>
        </member>
        <member name="F:Nucleus.Game.KnockbackEffect._Direction">
            <summary>
            Private backing member variable for the Direction property
            </summary>
        </member>
        <member name="P:Nucleus.Game.KnockbackEffect.Direction">
            <summary>
            The direction in which the element is to be knocked
            </summary>
        </member>
        <member name="F:Nucleus.Game.KnockbackEffect._Power">
            <summary>
            Private backing member variable for the Power property
            </summary>
        </member>
        <member name="P:Nucleus.Game.KnockbackEffect.Power">
            <summary>
            The power of the knockback effect (translates to the number of spaces an average-sized target will move)
            </summary>
        </member>
        <member name="P:Nucleus.Game.KnockbackEffect.ImpactEffect">
            <summary>
            The effect (if any) which will be applied should the knockback be stopped by the target
            hitting a blocking object.  This effect will be applied to both the target and the object
            they have collided with.
            </summary>
        </member>
        <member name="M:Nucleus.Game.KnockbackEffect.#ctor(System.Double)">
            <summary>
            Directionless constructor.
            Should be used for templates only.
            </summary>
            <param name="power"></param>
        </member>
        <member name="M:Nucleus.Game.KnockbackEffect.#ctor(Nucleus.Geometry.Vector,System.Double)">
            <summary>
            Directional constructor
            </summary>
            <param name="direction"></param>
            <param name="power"></param>
        </member>
        <member name="M:Nucleus.Game.KnockbackEffect.#ctor(Nucleus.Game.KnockbackEffect)">
            <summary>
            Duplication constructor
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:Nucleus.Game.PickUpItemEffect">
            <summary>
            An effect which picks up the target item and adds it to
            the inventory of the actor
            </summary>
        </member>
        <member name="T:Nucleus.Game.SelectNextItemEffect">
            <summary>
            Effect which will select the next item slot in the target's inventory
            </summary>
        </member>
        <member name="T:Nucleus.Game.SelectPreviousItemEffect">
            <summary>
            Effect to select the previous item slot in the target's inventory
            </summary>
        </member>
        <member name="T:Nucleus.Game.SFXEffect">
            <summary>
            Trigger an SFX
            </summary>
        </member>
        <member name="F:Nucleus.Game.SFXEffect._KeyWord">
            <summary>
            Private backing member variable for the KeyWord property
            </summary>
        </member>
        <member name="P:Nucleus.Game.SFXEffect.KeyWord">
            <summary>
            The keyword which defines the type of special effect to be created
            </summary>
        </member>
        <member name="F:Nucleus.Game.SFXEffect._Position">
            <summary>
            Private backing member variable for the Position property
            </summary>
        </member>
        <member name="P:Nucleus.Game.SFXEffect.Position">
            <summary>
            The position at which the effect is to be created, if applicable.
            </summary>
        </member>
        <member name="F:Nucleus.Game.SFXEffect._Direction">
            <summary>
            Private backing member variable for the Direction property
            </summary>
        </member>
        <member name="P:Nucleus.Game.SFXEffect.Direction">
            <summary>
            The direction in/path along which the effect should be orientated/moved, if applicable
            </summary>
        </member>
        <member name="F:Nucleus.Game.SFXEffect._UseTargetPosition">
            <summary>
            Private backing member variable for the UseTargetPosition property
            </summary>
        </member>
        <member name="P:Nucleus.Game.SFXEffect.UseTargetPosition">
            <summary>
            If true, the position of the target will be taken as the position of the effect
            </summary>
        </member>
        <member name="M:Nucleus.Game.SFXEffect.#ctor(System.String)">
            <summary>
            Trigger a special effect with the specified keyword
            </summary>
            <param name="keyword"></param>
        </member>
        <member name="M:Nucleus.Game.SFXEffect.#ctor(System.String,Nucleus.Geometry.Vector)">
            <summary>
            Trigger a special effect with the specified keyword at the specified position
            </summary>
            <param name="keyword"></param>
            <param name="position"></param>
        </member>
        <member name="M:Nucleus.Game.SFXEffect.#ctor(System.String,Nucleus.Geometry.Vector,Nucleus.Geometry.Vector)">
            <summary>
            Trigger a special effect with the specified keyword at the specified position
            in the specified direction
            </summary>
            <param name="keyword"></param>
            <param name="position"></param>
            <param name="direction"></param>
        </member>
        <member name="M:Nucleus.Game.SFXEffect.#ctor(System.String,System.Boolean)">
            <summary>
            Trigger a special effect with the specified keyword at (optionally)
            the position of the target
            </summary>
            <param name="keyword"></param>
            <param name="useTargetPosition"></param>
        </member>
        <member name="M:Nucleus.Game.SFXEffect.#ctor(System.String,System.Boolean,Nucleus.Geometry.Vector)">
            <summary>
            Trigger a special effect with the specified keyword at (optionally)
            the position of the target
            </summary>
            <param name="keyword"></param>
            <param name="useTargetPosition"></param>
            <param name="direction"></param>
        </member>
        <member name="M:Nucleus.Game.SFXEffect.#ctor(Nucleus.Game.SFXEffect)">
            <summary>
            Duplication constructor
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:Nucleus.Game.SFXImpactEffect">
            <summary>
            A SFX effect that produces an effect at a point on the target
            </summary>
        </member>
        <member name="T:Nucleus.Game.IDefense">
            <summary>
            Interface for components, status effects, items etc. that
            defend against damage
            </summary>
        </member>
        <member name="M:Nucleus.Game.IDefense.Defend(Nucleus.Game.Damage,Nucleus.Logs.IActionLog,Nucleus.Game.EffectContext)">
            <summary>
            Adjust the specified damage value based on this defense
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.Invincible">
            <summary>
            Temporary invincibility
            </summary>
        </member>
        <member name="T:Nucleus.Game.IStatusEffect">
            <summary>
            Interface for status effects
            </summary>
        </member>
        <member name="P:Nucleus.Game.IStatusEffect.TimeRemaining">
            <summary>
            The time remaining for this status effect.
            Should be set to double.NaN for those which
            will apply indefinitely.
            </summary>
        </member>
        <member name="P:Nucleus.Game.IStatusEffect.Description">
            <summary>
            The description string for the status effect (usually the effect's name)
            </summary>
        </member>
        <member name="M:Nucleus.Game.IStatusEffect.Merge(Nucleus.Game.IStatusEffect)">
            <summary>
            Merge another status effect into this one
            </summary>
            <param name="other"></param>
        </member>
        <member name="T:Nucleus.Game.Poisoned">
            <summary>
            Poisoned status effect.
            Does damage over time.
            </summary>
        </member>
        <member name="P:Nucleus.Game.Poisoned.TimeRemaining">
            <summary>
            The time remaining for this status effect.
            Should be set to double.NaN for those which
            will apply indefinitely.
            </summary>
        </member>
        <member name="T:Nucleus.Game.Shielded">
            <summary>
            Status effect applied when a character is being shielded from harm
            </summary>
        </member>
        <member name="M:Nucleus.Game.Shielded.Defend(Nucleus.Game.Damage,Nucleus.Logs.IActionLog,Nucleus.Game.EffectContext)">
            <summary>
            Adjust the specified damage value based on this defense
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.StatusEffect">
            <summary>
            Base class for status effects which provides a simple implementation
            of the IStatusEffect interface.  Note that not all status effects need
            inherit from this class - check the interface instead.
            </summary>
        </member>
        <member name="P:Nucleus.Game.StatusEffect.TimeRemaining">
            <summary>
            The time remaining for this status effect.
            Should be set to double.NaN for those which
            will apply indefinitely.
            </summary>
        </member>
        <member name="P:Nucleus.Game.StatusEffect.Description">
            <summary>
            The description of this status effect
            </summary>
        </member>
        <member name="M:Nucleus.Game.StatusEffect.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Game.StatusEffect.#ctor(System.Double)">
            <summary>
            Duration constructor
            </summary>
            <param name="duration"></param>
        </member>
        <member name="T:Nucleus.Game.StatusEffectCollection">
            <summary>
            A collection of status effects
            </summary>
        </member>
        <member name="T:Nucleus.Game.Faction">
            <summary>
            A player or AI-controlled faction
            </summary>
        </member>
        <member name="M:Nucleus.Game.Faction.#ctor">
            <summary>
            Initialise a blank faction
            </summary>
        </member>
        <member name="M:Nucleus.Game.Faction.#ctor(System.String)">
            <summary>
            Initialise a faction with the specified name
            </summary>
            <param name="name"></param>
        </member>
        <member name="M:Nucleus.Game.Faction.IsEnemy(Nucleus.Game.Faction)">
            <summary>
            Is this faction an enemy of the specified other faction?
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Faction.IsAlly(Nucleus.Game.Faction)">
            <summary>
            Is this faction an ally of the specified other faction?
            </summary>
            <param name="other"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Faction.AreEnemies(Nucleus.Model.Element,Nucleus.Model.Element)">
            <summary>
            Does elementB belong to a faction which is an enemy of the faction of elementA?
            </summary>
            <param name="elementA"></param>
            <param name="elementB"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.GameElement">
            <summary>
            An element which is specialised towards functioning as an entity
            in a game.
            </summary>
        </member>
        <member name="T:Nucleus.Game.InputFunction">
            <summary>
            An enumerated value representing different possible
            user input functions.
            </summary>
            <remarks>Values whose integer equivalent is a multiple
            of 1000 are 'top level' and taken for certain purposes
            as being equivalent to those within the range of the
            next 999 values.</remarks>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Undefined">
            <summary>
            The input function is not defined
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Abort">
            <summary>
            Abort/escape
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Move">
            <summary>
            Movement (in any direction)
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Up">
            <summary>
            Upwards movement
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Right">
            <summary>
            Rightwards movement
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Down">
            <summary>
            Downwards movement
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Left">
            <summary>
            Leftwards movement
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Interact">
            <summary>
            Use an interactive object
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.UseExit">
            <summary>
            Use a level exit from one stage to another
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Wait">
            <summary>
            A resting action
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.PickUp">
            <summary>
            Pick up an item
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Drop">
            <summary>
            Drop an item
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.DropSelected">
            <summary>
            Drop the currently selected item
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Ability_1">
            <summary>
            Use special ability 1
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Ability_2">
            <summary>
            Use special ability 2
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Ability_3">
            <summary>
            Use special ability 3
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Ability_4">
            <summary>
            Use special ability 4
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Ability_5">
            <summary>
            Use special ability 5
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Ability_6">
            <summary>
            Use special ability 6
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Ability_7">
            <summary>
            Use special ability 7
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Ability_8">
            <summary>
            Use special ability 8
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Ability_9">
            <summary>
            Use special ability 9
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.SelectNext">
            <summary>
            Select next menu item
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.SelectPrevious">
            <summary>
            Select previous menu item
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.ShowInfo">
            <summary>
            Show information about an item or option
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.UseSelected">
            <summary>
            Use the selected menu item
            </summary>
        </member>
        <member name="F:Nucleus.Game.InputFunction.Debug">
            <summary>
            Toggle debug mode
            </summary>
        </member>
        <member name="T:Nucleus.Game.InputFunctionExtensions">
            <summary>
            Extension methods for the InputFunction enum
            </summary>
        </member>
        <member name="M:Nucleus.Game.InputFunctionExtensions.DirectionVector(Nucleus.Game.InputFunction)">
            <summary>
            Get the vector which indicates the direction associated with this input
            (if any)
            </summary>
            <param name="iF"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.InputFunctionExtensions.ToTopLevel(Nucleus.Game.InputFunction)">
            <summary>
            Convert this input to a 'top level' input that represents a
            category of different inputs
            </summary>
            <param name="iF"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.InputFunctionExtensions.IsTopLevel(Nucleus.Game.InputFunction)">
            <summary>
            Is this a 'top level' input that represents a category of
            different sub-inputs?
            </summary>
            <param name="iF"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.InputManager">
            <summary>
            Manager class for user input
            </summary>
        </member>
        <member name="M:Nucleus.Game.InputManager.InputPress(Nucleus.Game.InputFunction)">
            <summary>
            Called when the user presses a key or button
            </summary>
            <param name="input">The input function pressed</param>
        </member>
        <member name="M:Nucleus.Game.InputManager.InputRelease(Nucleus.Game.InputFunction)">
            <summary>
            Called when the user releases a key or button
            </summary>
            <param name="input">The input function pressed</param>
        </member>
        <member name="T:Nucleus.Game.RoomTemplate">
            <summary>
            A template which is used to generate a room
            </summary>
        </member>
        <member name="F:Nucleus.Game.RoomTemplate._RoomType">
            <summary>
            Private backing member variable for the RoomType property
            </summary>
        </member>
        <member name="P:Nucleus.Game.RoomTemplate.RoomType">
            <summary>
            The type of the room
            </summary>
        </member>
        <member name="F:Nucleus.Game.RoomTemplate._Dimension1">
            <summary>
            Private backing member variable for the Dimension1 property
            </summary>
        </member>
        <member name="P:Nucleus.Game.RoomTemplate.Dimension1">
            <summary>
            The domain of possible values for the first dimension of this room.
            </summary>
        </member>
        <member name="F:Nucleus.Game.RoomTemplate._Dimension2">
            <summary>
            Private backing member variable for the Dimension2 property
            </summary>
        </member>
        <member name="P:Nucleus.Game.RoomTemplate.Dimension2">
            <summary>
            The domain of possible values for the second dimension of this room.
            </summary>
        </member>
        <member name="F:Nucleus.Game.RoomTemplate._EntryWidth">
            <summary>
            Private backing member variable for the EntryWidth property
            </summary>
        </member>
        <member name="P:Nucleus.Game.RoomTemplate.EntryWidth">
            <summary>
            The width of the entryway into this type of room
            </summary>
        </member>
        <member name="F:Nucleus.Game.RoomTemplate._ExitPlacement">
            <summary>
            Private backing member variable for the ExitPlacement property
            </summary>
        </member>
        <member name="P:Nucleus.Game.RoomTemplate.ExitPlacement">
            <summary>
            The logic for the placement of the primary exit from this room
            </summary>
        </member>
        <member name="F:Nucleus.Game.RoomTemplate._SproutTries">
            <summary>
            Private backing member variable for the SproutTries property
            </summary>
        </member>
        <member name="P:Nucleus.Game.RoomTemplate.SproutTries">
            <summary>
            The number of attempts that will be made to generate rooms coming off of one of this type
            </summary>
        </member>
        <member name="F:Nucleus.Game.RoomTemplate._MaxConnections">
            <summary>
            Private backing member variable for the MaxConnections property
            </summary>
        </member>
        <!-- Badly formed XML comment ignored for member "P:Nucleus.Game.RoomTemplate.MaxConnections" -->
        <member name="F:Nucleus.Game.RoomTemplate._SymmetryChance">
            <summary>
            Private backing member variable for the SymmetryChance property
            </summary>
        </member>
        <member name="P:Nucleus.Game.RoomTemplate.SymmetryChance">
            <summary>
            The chance of sprouting doorways symmetrically
            </summary>
        </member>
        <member name="F:Nucleus.Game.RoomTemplate._CorridorChance">
            <summary>
            Private backing member variable for the CorridorChance property
            </summary>
        </member>
        <member name="P:Nucleus.Game.RoomTemplate.CorridorChance">
            <summary>
            The chance of sprouting a corridor (or other circulation space)
            </summary>
        </member>
        <member name="F:Nucleus.Game.RoomTemplate._DoorChance">
            <summary>
            Private backing member variable for the DoorChance property
            </summary>
        </member>
        <member name="P:Nucleus.Game.RoomTemplate.DoorChance">
            <summary>
            The chance of creating a door between this and connected rooms.  The maximum chance of the two room templates will be used.
            </summary>
        </member>
        <member name="M:Nucleus.Game.RoomTemplate.GenTypeForCell(System.Int32,System.Int32,System.Int32,System.Int32,System.Int32,System.Int32)">
            <summary>
            Determine the generation type for a cell within a room
            with this template
            </summary>
            <param name="i"></param>
            <param name="iMin"></param>
            <param name="iMax"></param>
            <param name="j"></param>
            <param name="jMin"></param>
            <param name="jMax"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.Logs.ActionLog">
            <summary>
            A log which describe in-game player actions
            </summary>
        </member>
        <member name="F:Nucleus.Game.Logs.ActionLog._CurrentMessage">
            <summary>
            The message currently being written to.
            </summary>
        </member>
        <member name="M:Nucleus.Game.Logs.ActionLog.#ctor(Nucleus.Logs.LogScript,System.Object,System.Object)">
            <summary>
            Constructors
            </summary>
            <param name="script"></param>
        </member>
        <member name="M:Nucleus.Game.Logs.ActionLog.WriteText(System.String)">
            <summary>
            Write text to the log
            </summary>
            <param name="text"></param>
        </member>
        <member name="T:Nucleus.Game.Logs.ActionLogMessage">
            <summary>
            A message in an action log
            </summary>
        </member>
        <member name="P:Nucleus.Game.Logs.ActionLogMessage.Text">
            <summary>
            The text of the message
            </summary>
        </member>
        <member name="T:Nucleus.Game.SFXKeywords">
            <summary>
            Standard keywords used to denote predefined special effects
            </summary>
        </member>
        <member name="F:Nucleus.Game.SFXKeywords.Bang">
            <summary>
            A 'bang' explosion effect
            </summary>
        </member>
        <member name="F:Nucleus.Game.SFXKeywords.Bash">
            <summary>
            A 'bash' effect when one object strikes another
            </summary>
        </member>
        <member name="F:Nucleus.Game.SFXKeywords.CritBash">
            <summary>
            A 'bash' effect when a critical hit is performed
            </summary>
        </member>
        <member name="F:Nucleus.Game.SFXKeywords.Dust">
            <summary>
            A dusty 'footprint' effect
            </summary>
        </member>
        <member name="F:Nucleus.Game.SFXKeywords.Grab">
            <summary>
            An item pickup effect
            </summary>
        </member>
        <member name="F:Nucleus.Game.SFXKeywords.Heal">
            <summary>
            A healing buff effect
            </summary>
        </member>
        <member name="F:Nucleus.Game.SFXKeywords.Knock">
            <summary>
            The effect of one object knocking against another
            </summary>
        </member>
        <member name="F:Nucleus.Game.SFXKeywords.Open">
            <summary>
            The effect when a door is opened
            </summary>
        </member>
        <member name="F:Nucleus.Game.SFXKeywords.Slash">
            <summary>
            A melee-weapon slash effect
            </summary>
        </member>
        <member name="F:Nucleus.Game.SFXKeywords.Stab">
            <summary>
            A melee-weapon stab effect
            </summary>
        </member>
        <member name="T:Nucleus.Game.Stages.StageCollection`1">
            <summary>
            A collection of stages
            </summary>
            <typeparam name="TStage"></typeparam>
        </member>
        <member name="T:Nucleus.Game.Stages.StageTemplate">
            <summary>
            A template used to generate a stage
            </summary>
        </member>
        <member name="P:Nucleus.Game.Stages.StageTemplate.CreatureTable">
            <summary>
            The table of creatures which may be present in this stage
            </summary>
        </member>
        <member name="T:Nucleus.Game.GameSaveFile">
            <summary>
            An abstract base class for documents which act as a save file
            for a game state
            </summary>
        </member>
        <member name="M:Nucleus.Game.GameSaveFile.RetrieveState">
            <summary>
            Retrieve the game state (if any) stored in this save file
            </summary>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.GameSaveFile.Load(Nucleus.Base.FilePath)">
            <summary>
            Load a GameSaveFile from a file stored in binary format
            </summary>
            <param name="filePath">The path of the file to be loaded.</param>
            <returns>The loaded document, if a document could indeed be loaded.
            Else, null.</returns>
        </member>
        <member name="T:Nucleus.Game.GameSaveFile`1">
            <summary>
            An abstract base class for game save files which store a
            particular type of game state
            </summary>
            <typeparam name="TState"></typeparam>
        </member>
        <member name="F:Nucleus.Game.GameSaveFile`1._State">
            <summary>
            Private backing member variable for the State property
            </summary>
        </member>
        <member name="P:Nucleus.Game.GameSaveFile`1.State">
            <summary>
            The state which is stored in this file
            </summary>
        </member>
        <member name="M:Nucleus.Game.GameSaveFile`1.RetrieveState">
            <summary>
            Retrieve the game state (if any) stored in this save file
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.MapState">
            <summary>
            Base class for states which contains a MapStage
            </summary>
        </member>
        <member name="T:Nucleus.Game.ModalState">
            <summary>
            A game state which features modal interface elements (i.e. message boxes,
            inventory screens, etc.)
            </summary>
        </member>
        <member name="P:Nucleus.Game.ModalState.Modals">
            <summary>
            The collection of modal windows currently open within this state.
            Do not modify this collection directly, use OpenModal and CloseModal
            functions instead.
            </summary>
        </member>
        <member name="P:Nucleus.Game.ModalState.ActiveModal">
            <summary>
            Get the currently active modal window which has input
            focus.
            </summary>
        </member>
        <member name="P:Nucleus.Game.ModalState.IsModalOpen">
            <summary>
            Is any modal open?
            </summary>
        </member>
        <member name="M:Nucleus.Game.ModalState.OpenModal(Nucleus.Modals.ModalWindow)">
            <summary>
            Open a new modal window.  This will become the new active modal.
            </summary>
            <param name="modal"></param>
        </member>
        <member name="M:Nucleus.Game.ModalState.CloseModal(Nucleus.Modals.ModalWindow)">
            <summary>
            Close the specified modal window, or if no window
            is specified, the currently active one.
            Focus will pass to the next topmost modal.
            </summary>
            <param name="modal"></param>
        </member>
        <member name="M:Nucleus.Game.ModalState.CloseAllModals">
            <summary>
            Close all currently open modals
            </summary>
        </member>
        <member name="T:Nucleus.Game.RLState">
            <summary>
            A game state for Roguelikes
            </summary>
        </member>
        <member name="F:Nucleus.Game.RLState._Active">
            <summary>
            Private backing member variable for the Active property
            </summary>
        </member>
        <member name="P:Nucleus.Game.RLState.Active">
            <summary>
            The element who is currently activated for a turn.
            </summary>
        </member>
        <member name="F:Nucleus.Game.RLState._Log">
            <summary>
            Private backing member variable for the Log property
            </summary>
        </member>
        <member name="P:Nucleus.Game.RLState.Log">
            <summary>
            The logger which stores and displays messages to the user.  May be null, in which case no messages will be displayed.
            </summary>
        </member>
        <member name="P:Nucleus.Game.RLState.RNG">
            <summary>
            The random number generator used to provide randomisation
            </summary>
        </member>
        <member name="F:Nucleus.Game.RLState._AITurnDelay">
            <summary>
            The time delay to be used between the end of the player turn and the start of AI movement
            </summary>
        </member>
        <member name="F:Nucleus.Game.RLState._AITurnCountDown">
            <summary>
            Time remaining before AI turns can begin
            </summary>
        </member>
        <member name="F:Nucleus.Game.RLState._LastUpdateStart">
            <summary>
            The time that the last update started
            </summary>
        </member>
        <member name="M:Nucleus.Game.RLState.RandomiseTurnOrder">
            <summary>
            Randomise the turn order of all non-player turn-based elements
            </summary>
        </member>
        <member name="M:Nucleus.Game.RLState.InputRelease(Nucleus.Game.InputFunction,Nucleus.Geometry.Vector)">
            <summary>
            Called when the user releases a key or button
            </summary>
            <param name="input">The input function pressed</param>
            <param name="direction">The direction associated with the input,
            if applicable.</param>
        </member>
        <member name="M:Nucleus.Game.RLState.CreateTurnContext(Nucleus.Model.Element)">
            <summary>
            Create a new TurnContext parameter set for the specified element's turn
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.RLState.StartTurnOf(Nucleus.Model.Element)">
            <summary>
            Process the start of the turn
            </summary>
            <param name="element"></param>
        </member>
        <member name="M:Nucleus.Game.RLState.EndTurnOf(Nucleus.Model.Element)">
            <summary>
            Process the end of the turn
            </summary>
        </member>
        <member name="M:Nucleus.Game.RLState.DelayAITurn">
            <summary>
            Reset the AI turn delay countdown to provide a slight pause before
            the AI will take its turn.  Allows for player moves to be distingishable
            in the user interface.
            </summary>
        </member>
        <member name="M:Nucleus.Game.RLState.NextTurn">
            <summary>
            Progress to the next turn
            </summary>
        </member>
        <member name="M:Nucleus.Game.RLState.CleanUpDeleted">
            <summary>
            Clean up after any elements which have been deleted in this turn
            </summary>
        </member>
        <member name="M:Nucleus.Game.RLState.Save(Nucleus.Base.FilePath)">
            <summary>
            Save this state to the specified filepath
            </summary>
            <param name="filePath"></param>
        </member>
        <member name="T:Nucleus.Game.BasicGameState`1">
            <summary>
            A basic game state that implements the fundamental mechanics
            of a game in a fairly general way
            </summary>
        </member>
        <member name="F:Nucleus.Game.BasicGameState`1._Controlled">
            <summary>
            Private backing member variable for the Controlled property
            </summary>
        </member>
        <member name="P:Nucleus.Game.BasicGameState`1.Controlled">
            <summary>
            The game element which is currently directly under the player's control
            </summary>
        </member>
        <member name="F:Nucleus.Game.BasicGameState`1._Stage">
            <summary>
            Private backing member variable for the Stage property
            </summary>
        </member>
        <member name="P:Nucleus.Game.BasicGameState`1.Stage">
            <summary>
            The current stage
            </summary>
        </member>
        <member name="M:Nucleus.Game.BasicGameState`1.ChangeStage(`0)">
            <summary>
            Change the current stage.  This may be overridden to provide
            more specific logic on how stages should be changed.
            </summary>
            <param name="newStage"></param>
        </member>
        <member name="T:Nucleus.Game.EffectCollection">
            <summary>
            A collection of effects
            </summary>
        </member>
        <member name="T:Nucleus.Game.GameAction">
            <summary>
            An action is a process that may be performed by a game element
            which has one or more effects
            </summary>
        </member>
        <member name="F:Nucleus.Game.GameAction._Trigger">
            <summary>
            Private backing member variable for the Trigger property
            </summary>
        </member>
        <member name="P:Nucleus.Game.GameAction.Trigger">
            <summary>
            The input combination which will trigger this action.
            </summary>
        </member>
        <member name="F:Nucleus.Game.GameAction._Effects">
            <summary>
            Private backing member variable for the Effects property
            </summary>
        </member>
        <member name="P:Nucleus.Game.GameAction.Effects">
            <summary>
            The effects of this action on the target element(s)
            </summary>
        </member>
        <member name="F:Nucleus.Game.GameAction._SelfEffects">
            <summary>
            Private backing member variable for the Effects property
            </summary>
        </member>
        <member name="P:Nucleus.Game.GameAction.SelfEffects">
            <summary>
            The effects of this action on the element performing the action
            </summary>
        </member>
        <member name="P:Nucleus.Game.GameAction.ExecutionTime">
            <summary>
            The timestep necessary to execute this action.
            In a turn based game, this is the proportion
            of a turn this action takes.
            </summary>
        </member>
        <member name="M:Nucleus.Game.GameAction.Attempt(Nucleus.Logs.IActionLog,Nucleus.Game.EffectContext)">
            <summary>
            Attempt the action.  Returns true if successful, false if not.
            Should be overridden to check skill levels etc.
            </summary>
            <param name="log"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.GameAction.Enact(Nucleus.Logs.IActionLog,Nucleus.Game.EffectContext)">
            <summary>
            Enact this action
            </summary>
            <param name="log"></param>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.GameAction.PrePopulateContext(Nucleus.Game.EffectContext)">
            <summary>
            Populate the context data before attempting to execute the action
            </summary>
            <param name="context"></param>
        </member>
        <member name="M:Nucleus.Game.GameAction.RollToCrit(Nucleus.Game.EffectContext)">
            <summary>
            Test whether this set of effects from this action should be
            treated as a critical success.
            </summary>
            <param name="context"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.GameAction.ApplyEffects(Nucleus.Logs.IActionLog,Nucleus.Game.EffectContext,System.Boolean)">
            <summary>
            Apply the effects of the action to the target
            </summary>
            <param name="log"></param>
            <param name="context"></param>
        </member>
        <member name="M:Nucleus.Game.GameAction.ApplySelfEffects(Nucleus.Logs.IActionLog,Nucleus.Game.EffectContext)">
            <summary>
            Apply the self-effects of the action, targetting the actor performing
            the action
            </summary>
            <param name="log"></param>
            <param name="context"></param>
        </member>
        <member name="M:Nucleus.Game.GameAction.AIScore(Nucleus.Game.TurnContext,Nucleus.Game.ActionSelectionAI)">
            <summary>
            Generate a score for this action based on the specified
            set of weightings
            </summary>
            <param name="weights"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.GameAction.CanTarget(Nucleus.Model.Element)">
            <summary>
            Can this action target the specified element
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.GameEngine">
            <summary>
            A core engine for games and realtime simulations
            </summary>
        </member>
        <member name="F:Nucleus.Game.GameEngine._Instance">
            <summary>
            Private backing field for Instance
            </summary>
        </member>
        <member name="P:Nucleus.Game.GameEngine.Instance">
            <summary>
            The instance of the game engine
            </summary>
        </member>
        <member name="P:Nucleus.Game.GameEngine.LanguagePack">
            <summary>
            The current language pack used to define text
            </summary>
        </member>
        <member name="P:Nucleus.Game.GameEngine.Input">
            <summary>
            The sub-manager which handles user input
            </summary>
        </member>
        <member name="F:Nucleus.Game.GameEngine._State">
            <summary>
            Private backing member variable for the State property
            </summary>
        </member>
        <member name="P:Nucleus.Game.GameEngine.State">
            <summary>
            The current state
            </summary>
        </member>
        <member name="P:Nucleus.Game.GameEngine.SFX">
            <summary>
            The special effects supervisor
            </summary>
        </member>
        <member name="F:Nucleus.Game.GameEngine._Module">
            <summary>
            Private backing member variable for the Module property
            </summary>
        </member>
        <member name="P:Nucleus.Game.GameEngine.Module">
            <summary>
            The currently loaded module
            </summary>
        </member>
        <member name="P:Nucleus.Game.GameEngine.Resources">
            <summary>
            The resource loader
            </summary>
        </member>
        <member name="M:Nucleus.Game.GameEngine.StartUp">
            <summary>
            Perform engine initialisation.
            This should be done after a module has been loaded and a resource loader supplied.
            </summary>
        </member>
        <member name="M:Nucleus.Game.GameEngine.Reset">
            <summary>
            Reset the game engine back to it's initial state
            </summary>
        </member>
        <member name="M:Nucleus.Game.GameEngine.Update">
            <summary>
            Called every frame update
            </summary>
        </member>
        <member name="M:Nucleus.Game.GameEngine.LoadModule(Nucleus.Game.GameModule)">
            <summary>
            Load a module into the engine
            </summary>
            <param name="module"></param>
        </member>
        <member name="M:Nucleus.Game.GameEngine.LoadState(Nucleus.Base.FilePath,System.Boolean)">
            <summary>
            Load a state from a save file, optionally setting it as the current
            state.
            </summary>
            <param name="filePath">The filepath of the save file to load</param>
            <param name="makeCurrent">If true, the loaded state will be set as
            the current one.</param>
            <returns>The loaded state, or null if reading the file was unsuccessful.</returns>
        </member>
        <member name="T:Nucleus.Game.GameModule">
            <summary>
            Abstract base class for game modules.
            Modules define top-level information about a game including 
            how it should be initialised and run.
            </summary>
        </member>
        <member name="M:Nucleus.Game.GameModule.Initialise">
            <summary>
            Initialise the game module
            </summary>
        </member>
        <member name="M:Nucleus.Game.GameModule.StartingState">
            <summary>
            Get the state which starts this game.
            </summary>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.GameStage">
            <summary>
            A class to hold data about a stage or level in a game.
            </summary>
        </member>
        <member name="T:Nucleus.Game.GameState">
            <summary>
            Abstract base class for states within a game (levels, menus etc.)
            </summary>
        </member>
        <member name="P:Nucleus.Game.GameState.Elements">
            <summary>
            The collection of currently active game elements
            </summary>
        </member>
        <member name="F:Nucleus.Game.GameState._DebugModeOn">
            <summary>
            Private backing field for DebugModeOn
            </summary>
        </member>
        <member name="P:Nucleus.Game.GameState.DebugModeOn">
            <summary>
            Is debug mode currently active?  Debug mode enables extra developer functionality
            to aid with testing and debugging
            </summary>
        </member>
        <member name="P:Nucleus.Game.GameState.DebugCommands">
            <summary>
            Get the current library of debug commands
            </summary>
        </member>
        <member name="M:Nucleus.Game.GameState.StartUp">
            <summary>
            Perform state initialisation
            </summary>
        </member>
        <member name="M:Nucleus.Game.GameState.Update(Nucleus.Game.UpdateInfo)">
            <summary>
            Called every frame update
            </summary>
        </member>
        <member name="M:Nucleus.Game.GameState.InputPress(Nucleus.Game.InputFunction,Nucleus.Geometry.Vector)">
            <summary>
            Called when the user presses a key or button
            </summary>
            <param name="input">The input function pressed</param>
            <param name="direction">The direction associated with the input,
            if applicable.</param>
        </member>
        <member name="M:Nucleus.Game.GameState.InputRelease(Nucleus.Game.InputFunction,Nucleus.Geometry.Vector)">
            <summary>
            Called when the user releases a key or button
            </summary>
            <param name="input">The input function pressed</param>
            <param name="direction">The direction associated with the input,
            if applicable.</param>
        </member>
        <member name="M:Nucleus.Game.GameState.RunDebugCommand(System.String)">
            <summary>
            Run a debug command
            </summary>
            <param name="command"></param>
        </member>
        <member name="T:Nucleus.Game.IEffect">
            <summary>
            Interface for an effect which is to be applied to an element
            </summary>
        </member>
        <member name="M:Nucleus.Game.IEffect.Apply(Nucleus.Logs.IActionLog,Nucleus.Game.EffectContext)">
            <summary>
            Attempt to apply this effect to an element
            </summary>
            <param name="target">The target element</param>
            <param name="log">A message log used to report back the outcome of the effect</param>
            <param name="context">The context in which the effect is being applied</param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.IEffect`1">
            <summary>
            Generic interface for an effect which is to be applied to a target
            object of a specifed type
            </summary>
            <typeparam name="TTarget"></typeparam>
        </member>
        <member name="P:Nucleus.Game.IEffect`1.Target">
            <summary>
            The target of the effect
            </summary>
        </member>
        <member name="T:Nucleus.Game.IEffectExtensions">
            <summary>
            Extension methods for the IEffect interface
            </summary>
        </member>
        <member name="M:Nucleus.Game.IEffectExtensions.ApplyAll``1(System.Collections.Generic.IList{Nucleus.Game.IEffect{``0}},Nucleus.Logs.IActionLog)">
            <summary>
            Apply all effects in this collection to the target object
            </summary>
            <typeparam name="TTarget"></typeparam>
            <param name="list"></param>
            <param name="target"></param>
            <param name="log"></param>
        </member>
        <member name="T:Nucleus.Game.MapCellCollider">
            <summary>
            A data component which may be attached to elements and map cells
            which will register a collision with solid objects in the same map cell
            </summary>
        </member>
        <member name="F:Nucleus.Game.MapCellCollider._Solid">
            <summary>
            Private backing member variable for the Solid property
            </summary>
        </member>
        <member name="P:Nucleus.Game.MapCellCollider.Solid">
            <summary>
            Is this collider solid?  Solid objects will register collisions with other solid objects.
            </summary>
        </member>
        <member name="P:Nucleus.Game.MapCellCollider.BlockingCheck">
            <summary>
            Get the condition used to check whether another element blocks this entity's
            movement.  (By default this just checks if the object is solid)
            </summary>
        </member>
        <member name="M:Nucleus.Game.MapCellCollider.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Game.MapCellCollider.CanEnter(Nucleus.Geometry.MapCell)">
            <summary>
            Can the owner of this collider enter the specified cell?
            </summary>
            <param name="cell"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.MapCellCollider.Blocker(Nucleus.Geometry.MapCell)">
            <summary>
            Get the element which is blocking the owner of this collider
            from entering the specified cell.  If this returns null, there
            is no blocking element in the cell and the owner may enter it.
            </summary>
            <param name="cell"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.MapStage">
            <summary>
            A game stage which represents level geometry via a map
            </summary>
        </member>
        <member name="F:Nucleus.Game.MapStage._Elements">
            <summary>
            Private backing member variable for the Elements property
            </summary>
        </member>
        <member name="P:Nucleus.Game.MapStage.Elements">
            <summary>
            The collection of currently active game elements in this stage
            </summary>
        </member>
        <member name="F:Nucleus.Game.MapStage._Map">
            <summary>
            Private backing member variable for the Map property
            </summary>
        </member>
        <member name="P:Nucleus.Game.MapStage.Map">
            <summary>
            The spatial map of the stage
            </summary>
        </member>
        <member name="P:Nucleus.Game.MapStage.Borders">
            <summary>
            Curves representing the border between walkable and solid space
            </summary>
        </member>
        <member name="M:Nucleus.Game.MapStage.AddElement(Nucleus.Game.GameElement,System.Int32)">
            <summary>
            Add an element residing in the specified cell
            </summary>
            <param name="element"></param>
            <param name="cellIndex"></param>
        </member>
        <member name="T:Nucleus.Game.MoveCellEffect">
            <summary>
            An effect which will move an element to a specific cell
            </summary>
        </member>
        <member name="F:Nucleus.Game.MoveCellEffect._MoveTo">
            <summary>
            Private backing member variable for the MoveTo property
            </summary>
        </member>
        <member name="P:Nucleus.Game.MoveCellEffect.MoveTo">
            <summary>
            The index of the mapcell to move to
            </summary>
        </member>
        <member name="T:Nucleus.Game.RLStateSaveFile">
            <summary>
            Document which saves an RLState
            </summary>
        </member>
        <member name="T:Nucleus.Game.Damage">
            <summary>
            Damage stat
            </summary>
        </member>
        <member name="P:Nucleus.Game.Damage.DamageType">
            <summary>
            The type of damage
            </summary>
        </member>
        <member name="M:Nucleus.Game.Damage.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Game.Damage.#ctor(System.Double)">
            <summary>
            Value constructor.  Base damage type.
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Nucleus.Game.Damage.#ctor(System.Double,Nucleus.Game.DamageType)">
            <summary>
            Value, type constructor.
            </summary>
            <param name="value"></param>
            <param name="damageType"></param>
        </member>
        <member name="M:Nucleus.Game.Damage.#ctor(Nucleus.Game.Damage)">
            <summary>
            Duplication constructor
            </summary>
            <param name="other"></param>
        </member>
        <member name="M:Nucleus.Game.Damage.WithValue(System.Double)">
            <summary>
            Create a copy of this damage with the specified new value
            </summary>
            <param name="value"></param>
            <returns></returns>
        </member>
        <member name="M:Nucleus.Game.Damage.op_Multiply(Nucleus.Game.Damage,System.Double)">
            <summary>
            Multiplication operator
            </summary>
            <param name="d"></param>
            <param name="scalar"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.IModifier`1">
            <summary>
            Interfaces for components, status effects and items which modify stats
            </summary>
            <typeparam name="T"></typeparam>
        </member>
        <member name="M:Nucleus.Game.IModifier`1.Modify(`0)">
            <summary>
            Modify the specified stat
            </summary>
            <param name="stat"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.Stats.Knockback">
            <summary>
            Knockback stat
            </summary>
        </member>
        <member name="T:Nucleus.Game.Stat">
            <summary>
            Base class for game stats which may be modified
            by equipment, status effects and so on
            </summary>
        </member>
        <member name="P:Nucleus.Game.Stat.Value">
            <summary>
            The current value
            </summary>
        </member>
        <member name="M:Nucleus.Game.Stat.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Game.Stat.#ctor(System.Double)">
            <summary>
            Value constructor
            </summary>
            <param name="value"></param>
        </member>
        <member name="M:Nucleus.Game.Stat.op_Implicit(Nucleus.Game.Stat)~System.Double">
            <summary>
            Implicit conversion to a double
            </summary>
            <param name="value"></param>
        </member>
        <member name="T:Nucleus.Game.TurnContext">
            <summary>
            Object to contain context data about a turn in a turn-based game
            </summary>
        </member>
        <member name="P:Nucleus.Game.TurnContext.State">
            <summary>
            The current state
            </summary>
        </member>
        <member name="P:Nucleus.Game.TurnContext.Stage">
            <summary>
            The current stage
            </summary>
        </member>
        <member name="P:Nucleus.Game.TurnContext.Element">
            <summary>
            The element whose turn has completed
            (and whose components are currently being activated)
            </summary>
        </member>
        <member name="P:Nucleus.Game.TurnContext.RNG">
            <summary>
            The random number generator used to provide randomisation
            </summary>
        </member>
        <member name="P:Nucleus.Game.TurnContext.Log">
            <summary>
            The log to be used to record textual output
            </summary>
        </member>
        <member name="M:Nucleus.Game.TurnContext.IsPlayerControlled(Nucleus.Model.Element)">
            <summary>
            Is the specified element player-controlled?
            </summary>
            <param name="element"></param>
            <returns></returns>
        </member>
        <member name="T:Nucleus.Game.UpdateInfo">
            <summary>
            Information about an update cycle
            </summary>
        </member>
        <member name="F:Nucleus.Game.UpdateInfo._TimeStep">
            <summary>
            Private backing member variable for the TimeStep property
            </summary>
        </member>
        <member name="P:Nucleus.Game.UpdateInfo.TimeStep">
            <summary>
            The timestep between the previous update and this one, in seconds.
            </summary>
        </member>
        <member name="M:Nucleus.Game.UpdateInfo.#ctor(System.Double)">
            <summary>
            Initialise a new UpdateInfo
            </summary>
            <param name="timeStep"></param>
        </member>
        <member name="T:Nucleus.Modals.Header">
            <summary>
            A header-style segment of text
            </summary>
        </member>
        <member name="M:Nucleus.Modals.Header.#ctor(System.String)">
            <summary>
            Text constructor
            </summary>
            <param name="text"></param>
        </member>
        <member name="T:Nucleus.Modals.Keywords">
            <summary>
            A paragraph which displays a list of keywords or tags
            </summary>
        </member>
        <member name="M:Nucleus.Modals.Keywords.#ctor(System.String)">
            <summary>
            Text constructor
            </summary>
            <param name="text"></param>
        </member>
        <member name="T:Nucleus.Modals.ModalWindow">
            <summary>
            A back-end representation of a modal window.
            This allows for window content and functionality to be defined
            within the 'business logic', however the display and implementation
            of the window itself is the responsibility of the front-end
            </summary>
        </member>
        <member name="P:Nucleus.Modals.ModalWindow.Contents">
            <summary>
            The main contents of the window
            </summary>
        </member>
        <member name="M:Nucleus.Modals.ModalWindow.#ctor">
            <summary>
            Default constructor
            </summary>
        </member>
        <member name="M:Nucleus.Modals.ModalWindow.#ctor(System.String)">
            <summary>
            Title constructor
            </summary>
            <param name="title"></param>
        </member>
        <member name="T:Nucleus.Modals.ModalWindowCollection">
            <summary>
            A collection of modal windows
            </summary>
        </member>
        <member name="T:Nucleus.Modals.Paragraph">
            <summary>
            A paragraph of text to be displayed as part of a document
            </summary>
        </member>
        <member name="P:Nucleus.Modals.Paragraph.Text">
            <summary>
            The text to be displayed in the paragraph
            </summary>
        </member>
        <member name="M:Nucleus.Modals.Paragraph.#ctor(System.String)">
            <summary>
            Text constructor
            </summary>
            <param name="text"></param>
        </member>
        <member name="T:Nucleus.Logs.IActionLog">
            <summary>
            An interface for log objects which report on actions
            </summary>
        </member>
        <member name="T:Nucleus.Logs.IActionLogExtensions">
            <summary>
            Extension methods for the IActionLog interface
            </summary>
        </member>
        <member name="M:Nucleus.Logs.IActionLogExtensions.WriteScripted(Nucleus.Logs.IActionLog,Nucleus.Game.EffectContext,System.String,System.Object[])">
            <summary>
            Write a pre-scripted entry to the log based on a key and a set of subject objects,
            if they are currently known to the player
            </summary>
            <param name="key"></param>
            <param name="subjects"></param>
            <remarks>To be written, at least one element in the subjects must be known to the player.
            Any unknown subjects will be replaced with a dummy 'something' element.</remarks>
        </member>
    </members>
</doc>
